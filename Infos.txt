La version du leak est 1142, celle en dev est 1344
Le serveur est loedata.legendsofequestria.com (82.147.19.83)
On dirait que quand on lui envoie login.bin (donc avec authresponse=true) il attend quelque chose d'autre, il se bloque en attente
=> Need a way to force the game to accept auth but let it connect to the server after it,maybe spam replies to answer before the real server does
Le .exe c'est le moteur du jeu, c'est Unity, y'as rien d'interessant dedans.
Les trucs cools sont dans LoE_Data, les ressource directement dedans
Le vrai code est probablement dans managed : "LegendsOfEquestria.Data.dll", et "System.Core.dll"
Le code du jeu est dans Assembly-CSharp.dll, voir TwilightSparkle->WebAuth->MoveNext pour le login code
=> Au login si authenticated=true et que la taille de la reponse >5, il attend une liste de serveurs
=> Le code utilise response_5, un tableau de string avec une ligne par case
=> response_5 c'est le tableau des lignes de la reponse HTTP (apres la taille de la reponse). 
=> Donc pour loginVersionFail, response_5[0]="versionresponse:" et response_5[1]="1344"

Dump wireshark a la connection, avec version du leak :
### Client :
POST /login.php HTTP/1.1
User-Agent: UnityPlayer/3.5.3f3 (http://unity3d.com)
Host: loedata.legendsofequestria.com
Accept: */*
Content-Length: 95
Content-Type: application/x-www-form-urlencoded
commfunction=login&username=tux3&passhash=efc8ed71e9d9f3039f06d43133ded18579dd31d5&version=1142
### Serveur :
HTTP/1.1 200 OK
Server: nginx
Date: Fri, 21 Jun 2013 19:54:32 GMT
Content-Type: text/html
Transfer-Encoding: chunked
Connection: keep-alive
X-Powered-By: PHP/5.3.25
Vary: Accept-Encoding,User-Agent
15
versionresponse:
1344
0

=> Accept: */*
=> Pour login reussi il faut response_5 comme ça (les ###TRUC###, c'est a remplacer par une valeur correcte)
[0]:string		authresponse:
[1]:string		true
[2]:string		###SESSIONKEY###
[3]:int			###GACCESS###
[4-X]:string	###SERVNAME###;###SERVLOCATION###;###SERVPORT###

=> Le dossier des donnees du jeu est : C:/Users/Tux/AppData/LocalLow/LoE/Legends of Equestria/
=> Make sure the encoding of the XML files is OK (its written at the top (should be UTF16))
=> The leaked game can't read XML files with elements inside elements, that's why Recipes.xml bugs
==> Replace the reagents by <Reagents></Reagents> to make it work on the leak

=> Now we need to answer the UDP connect. Check Lidgren and https://github.com/jbruening/PNet, it's the library used for UDP communication.
==> See in NetworkMenu->AwakeAfterAuthentifiation
==> The game uses PNet and PNet uses Lidgren, in the end Lidgren does all the work (including the UDP 'handshake')
==> When a connection request is received, you can call Approve() or Deny() to finish the handshake !
==> Copy the handshake code, complete with the NetworkTime thing

8300000801 04504e6574 3a7a4f815c8c4ee6 9cf35b43 04 74757833 0a 53455353494f4e4b4559

Plaintext (dots is unprintable char) :
......PNet.......Wf..D.tux3.SESSIONKEY

=> The 5 first bytes are the Header
=> The 5 next are the AppId
=> The 8 next are the UniqueId
=> The 4 next are the timestamp
=> Connect reply is connect without the LocalHail and with id 0x84, thus 22 bytes long

8300000801							Header
04504e6574 							AppId
3a7a4f815c8c4ee6					UniqueId
9cf35b43							Timestamp
04747578330a53455353494f4e4b4559	Message(LocalHail)

=> The first byte is probably not part of the AppId but rather the type of message
==> Message types :
Connect = 0x83,
ConnectResponse = 0x84,
ConnectionEstablished = 0x85,
Acknowledge = 0x86,
Disconnect = 0x87,
Discovery = 0x88,
DiscoveryResponse = 0x89,
ExpandMTURequest = 8C,
ExpandMTUSuccess = 0x8d,
LibraryError = 0x80,
NatIntroduction = 0x8b,
NatPunchMessage = 0x8a,
Ping = 0x81,
Pong = 0x82,
Unconnected = 0,
UserReliableOrdered1 = 0x43,
UserReliableOrdered10 = 0x4c,
UserReliableOrdered11 = 0x4d,
UserReliableOrdered12 = 0x4e,
UserReliableOrdered13 = 0x4f,
UserReliableOrdered14 = 80,
UserReliableOrdered15 = 0x51,
UserReliableOrdered16 = 0x52,
UserReliableOrdered17 = 0x53,
UserReliableOrdered18 = 0x54,
UserReliableOrdered19 = 0x55,
UserReliableOrdered2 = 0x44,
UserReliableOrdered20 = 0x56,
UserReliableOrdered21 = 0x57,
UserReliableOrdered22 = 0x58,
UserReliableOrdered23 = 0x59,
UserReliableOrdered24 = 90,
UserReliableOrdered25 = 0x5b,
UserReliableOrdered26 = 0x5c,
UserReliableOrdered27 = 0x5d,
UserReliableOrdered28 = 0x5e,
UserReliableOrdered29 = 0x5f,
UserReliableOrdered3 = 0x45,
UserReliableOrdered30 = 0x60,
UserReliableOrdered31 = 0x61,
UserReliableOrdered32 = 0x62,
UserReliableOrdered4 = 0x46,
UserReliableOrdered5 = 0x47,
UserReliableOrdered6 = 0x48,
UserReliableOrdered7 = 0x49,
UserReliableOrdered8 = 0x4a,
UserReliableOrdered9 = 0x4b,
UserReliableSequenced1 = 0x23,
UserReliableSequenced10 = 0x2c,
UserReliableSequenced11 = 0x2d,
UserReliableSequenced12 = 0x2e,
UserReliableSequenced13 = 0x2f,
UserReliableSequenced14 = 0x30,
UserReliableSequenced15 = 0x31,
UserReliableSequenced16 = 50,
UserReliableSequenced17 = 0x33,
UserReliableSequenced18 = 0x34,
UserReliableSequenced19 = 0x35,
UserReliableSequenced2 = 0x24,
UserReliableSequenced20 = 0x36,
UserReliableSequenced21 = 0x37,
UserReliableSequenced22 = 0x38,
UserReliableSequenced23 = 0x39,
UserReliableSequenced24 = 0x3a,
UserReliableSequenced25 = 0x3b,
UserReliableSequenced26 = 60,
UserReliableSequenced27 = 0x3d,
UserReliableSequenced28 = 0x3e,
UserReliableSequenced29 = 0x3f,
UserReliableSequenced3 = 0x25,
UserReliableSequenced30 = 0x40,
UserReliableSequenced31 = 0x41,
UserReliableSequenced32 = 0x42,
UserReliableSequenced4 = 0x26,
UserReliableSequenced5 = 0x27,
UserReliableSequenced6 = 40,
UserReliableSequenced7 = 0x29,
UserReliableSequenced8 = 0x2a,
UserReliableSequenced9 = 0x2b,
UserReliableUnordered = 0x22,
UserSequenced1 = 2,
UserSequenced10 = 11,
UserSequenced11 = 12,
UserSequenced12 = 13,
UserSequenced13 = 14,
UserSequenced14 = 15,
UserSequenced15 = 0x10,
UserSequenced16 = 0x11,
UserSequenced17 = 0x12,
UserSequenced18 = 0x13,
UserSequenced19 = 20,
UserSequenced2 = 3,
UserSequenced20 = 0x15,
UserSequenced21 = 0x16,
UserSequenced22 = 0x17,
UserSequenced23 = 0x18,
UserSequenced24 = 0x19,
UserSequenced25 = 0x1a,
UserSequenced26 = 0x1b,
UserSequenced27 = 0x1c,
UserSequenced28 = 0x1d,
UserSequenced29 = 30,
UserSequenced3 = 4,
UserSequenced30 = 0x1f,
UserSequenced31 = 0x20,
UserSequenced32 = 0x21,
UserSequenced4 = 5,
UserSequenced5 = 6,
UserSequenced6 = 7,
UserSequenced7 = 8,
UserSequenced8 = 9,
UserSequenced9 = 10,
UserUnreliable = 1


=> See Lidgren->NetConnection->ReceiveHandshake

=> Atm you just need to get the UDP handshake right
==> Take two games on different computers but same network
==> Each game connect to the other one with the server list
==> They should at least complete the handshake before the weird but-this-aint-a-server! stuff happens
==> Wireshark on the other computer's ip
===> It's not working on Marie's computer

=> Make sure the UDP reply is really sent. I never saw it on Wireshark when testing LAN game-to-game connection.

=> Run a Lidgren demo ! Then wireshark through the handshake !
==> In the downladed lidgren lib there are samples

=> Pour se connecter ca fait (aves les size comme example) 0x83 (size 47) - 0x84 (size 22) - 0x85 (size 9)
=> Ensuite il y a des Ping 0x81 et Pong 0x82 de temps en temps
=> Et pour envoyer un message une fois qu'on est connecté c'est 0x43 et on recoit un acknoledge 0x86

=> Packet Header :
8 bit 		NetMessageType
1 bit		Fragment?
15 bits		Sequence number
16 bits		Payload length in bits

=> Fragment et Sequence number sont toujours à 0 pour le handshake et le ping

=> Now it connects and then timeouts, the server is supposed to send something, maybe the RPC stuff in NetworkMenu

=> case msg.readByte == 5, activate onRoomChange with a readString, wich is check in NetworkMenu.Awake wich activates loadLevel !

char peer0_0[] = {
0x81, 0x00, 0x00, 0x08, 0x00, 0x03 };
char peer1_0[] = {
0x82, 0x00, 0x00, 0x28, 0x00, 0x03, 0x4f, 0x1e, 
0x72, 0x42 };
char peer1_1[] = {
0x81, 0x00, 0x00, 0x08, 0x00, 0x03 };
char peer0_1[] = {
0x82, 0x00, 0x00, 0x28, 0x00, 0x03, 0xe0, 0x68, 
0xe7, 0x44 };

char peer0_45[] = {
0x43, 0x00, 0x00, 0x40, 0x00, 0x07, 0x54, 0x65, 
0x73, 0x74, 0x4d, 0x73, 0x67 };
char peer1_35[] = {
0x86, 0x00, 0x00, 0x18, 0x00, 0x43, 0x00, 0x00 };

char peer0_48[] = {
0x43, 0x02, 0x00, 0x48, 0x00, 0x08, 0x54, 0x65, 
0x73, 0x74, 0x4d, 0x73, 0x67, 0x32 };
char peer1_38[] = {
0x86, 0x00, 0x00, 0x18, 0x00, 0x43, 0x01, 0x00 };

char peer0_51[] = {
0x43, 0x04, 0x00, 0x48, 0x00, 0x08, 0x54, 0x65, 
0x73, 0x74, 0x4d, 0x73, 0x67, 0x33 };
char peer1_41[] = {
0x86, 0x00, 0x00, 0x18, 0x00, 0x43, 0x02, 0x00 };

86 00 00 18 00 
00 00 00 43 00 00

=> The connection times out probably because we don't reply to the pings nor acknoledge the messages !
=> Au lieu de supprimer tout le message quand on le traite, supprimer seulement ce message en lisant sa taille dans le header (faire fromRawData(data()+taille)

=> Now the game is on standby and never times out. But we need to send something. (probably a LoadLevel command or something)

=> Le jeu utilise des 'RPC' pour communiquer, c'est surement avec ça qu'on doit lui demander de charger un niveau

=> If you force the LoadLevel you get this message tons of times :
480000080006
It's a 0x48, communication on UserReliableOrdered6 !

public enum NetIncomingMessageType
{
    ConnectionApproval = 4,
    ConnectionLatencyUpdated = 0x1000,
    Data = 8,
    DebugMessage = 0x100,
    DiscoveryRequest = 0x20,
    DiscoveryResponse = 0x40,
    Error = 0,
    ErrorMessage = 0x400,
    NatIntroductionSuccess = 0x800,
    Receipt = 0x10,
    StatusChanged = 1,
    UnconnectedData = 2,
    VerboseDebugMessage = 0x80,
    WarningMessage = 0x200
}

?>The main loop of Lidgren is heartbeat

PnetU
=>Message reception :
Net.Update -> if NetIncomingMessageType = Data (8) goto
Net.Consume -> if SequenceChannel = 5 goto
Net.ProcessUtils -> if readByte = 5 goto
OnRoomChange readString

=> At startup the server is probably supposed to send the player info (charatcer type, game save, ...)
=> IIRC at login there is a player select/create screen.
?=> There is probably a different channel for this, ProcessUtils doesn't seem to manage this kind of stuff, but more like ingame object/scene managment

?> So, all data message are processed in Net.Consume, find what each channel does !
?=> 5		PNetU.Net.ProcessUtils
?=> 3		Assembly-CSharp.NetworkMenu.ProcessRCP

In ProcessRPC there are calls to CharacterCreator !!
See num3=1 and num3=0x7f

=> A RPC is a call to a function through the network, it could be on a different computer.

==>Remote Procedure Calls
Remote Procedure Calls (RPCs) are used to invoke functions on other computers across the network, although the "network" can also mean the message channel between the client and server when they are both running on the same computer. Clients can send RPCs to the server, and the server can send RPCs to one or more clients. Most commonly, they are used for actions that happen infrequently. For example, if a client flips a switch to open a door, it can send an RPC to the server telling it that the door has been opened. The server can then send another RPC to all clients, invoking their local functions to open that same door. They are used for managing and executing individual events.

==>State Synchronization
State Synchronization is used to share data that is constantly changing. The best example of this would be a player's position in an action game. The player is always moving, running around, jumping, etc. All the other players on the network, even the ones that are not controlling this player locally, need to know where he is and what he is doing. By constantly relaying data about this player's position, the game can accurately represent that position to the other players.
This kind of data is regularly and frequently sent across the network. Since this data is time-sensitive, and it requires time to travel across the network from one machine to another, it is important to reduce the amount of data that is sent as far as possible. In simpler terms, state synchronization naturally requires a lot of bandwidth, so you should aim to use as little bandwidth as possible. 

==>Network Views
Network Views are the main component involved in sharing data across the network. They allow two kinds of network communication: State Synchronization and Remote Procedure Calls.
Network Views keep watch on particular objects to detect changes. These changes are then shared to the other clients on the network to ensure the change of state is noted by all of them. This concept is known as state synchronization and you can read about it further on the State Synchronization page.
There are some situations where you would not want the overhead of synchronizing state between clients, for example, when sending out the position of a new object or respawned player. Since events like this are infrequent, it does not make sense to synchronize the state of the involved objects. Instead, you can use a remote procedure call to tell the clients or server to perform operations like this. More information about Remote Procedure Calls can be found on the RPC manual page. 

=> See the disassembled code and search where the important functions are called

=> Look at the other DLLs ! See in LoE.shared :

public class StaticRPCIDs
{
    // Fields
    public const byte Announce = 0xc9;
    public const byte BeginDialog = 11;
    public const byte ChatMessage = 15;
    public const byte Delete = 0xcd;
    public const byte EndDialog = 13;
    public const byte EnteredTrigger = 10;
    public const byte Error = 0x7f;
    public const byte GetPonies = 1;
    public const byte Kick = 200;
    public const byte Mute = 0xcc;
    public const byte RemovePony = 2;
    public const byte Rename = 0xcb;
    public const byte ServerInvoke = 0xff;
    public const byte SetDialogMessage = 0x11;
    public const byte SetDialogOptions = 12;
    public const byte SetQuests = 14;
    public const byte Tele = 0xce;
    public const byte Whois = 0xca;
}

=> The code of the wordfilter is in LoE.shared

=> Le Consume active des onDeserializeStream dans des NetworkViews inconnues, recherche onDeserializeStream pour trouver les fonctions qui utilisent cette valeur
=> Voir aussi les CallRPC, rechercher les fonctions qui demandent un NetIncomingMessage

=> DO IT, cherche les CallRPC avec Visual, toute les fonctions qui s'en serve recoivent des données du reseau, le code du PonyCreator or whatever doit etre dedans

=> Try to remove most of the modified code is possible. You shouldn't have to make a LoadStatic

=> C'est peut-etre un LoadLevel ! Genre le serveur fait LoadLevel (CharacterSelect)
==> Trouver la liste de tout les levels

===> Scenes, from "mainData" :
Assets/Scenes/MainMenu.unity
Assets/Scenes/Characters.unity
Assets/Scenes/PonyVille/PonyVille.unity
Assets/Scenes/SugarCubeCorner/SugarCubeCorner.unity
Assets/Scenes/Gem Mines/GemMines.unity
Assets/Scenes/Appaloosa/Appaloosa.unity
Assets/Scenes/SweetAppleAcres/SweetAppleAcres.unity
Assets/Scenes/Everfree/Everfree1.unity
Assets/Scenes/Everfree/Zecoras.unity
Assets/Scenes/Everfree/Everfree3.unity
Assets/Scenes/Tartarus/Tartarus.unity
Assets/Scenes/Minigames/minigameLoader.unity
Assets/Scenes/Minigames/PonyMuncher/PM-Lvl1.unity
Assets/Scenes/Ponyville Library/1stFloor/Ponyville Library 1st floor.unity
Assets/Scenes/Ponyville Library/2ndFloor/Ponyville Library 2nd floor.unity
Assets/Scenes/Raritys Boutique/RaritysBoutique.unity
Assets/Scenes/Canterlot/Canterlot.unity
Assets/Scenes/Transitions/Cottage.unity
Assets/Scenes/Cloudsdale/Cloudsdale.unity

====> OMIGOSH C'EST CA ! C'EST UNE SCENE !
=========> AU DEMARRAGE CHARGER AUTOMATIQUEMENT "characters" POUR L'ECRAN DE SELECTION DE PERSONNAGE !!!

=> Implement ressource extraction of XML files
=> Le serveur envoie ce messgae des qu'on charge la scene characters :
48 00 00 08 00 06
=> Sans le header c'est juste le byte 0x06. C'est surement un requete pour recuperer la liste de personnages !!!!
=> Dans characterCreator.cs rechercher Loading Pony Characters, le netcode doit etre pas loin
==> Il attent peut-etre la requete ponies, on peut l'envoyer vide, ca marche

=> When creating a character and hitting play the game tries to save the character, it send character data (for example SunButt) :
460000b00101ffffffff0753756e427574740302170000000600000000000000ffcdfd80ffedffffe849d1ff80ff8000000100000000000000803f
==> If you send back the empty ponies list, it just cancels the save and goes back to the editor.
===> It probably expects you to send back a correct ponies table
====> The the serialization/deserialization classes or just find a way to do it manually it shouldn't be that hard

public class PonyData : INetSerializable
	public Color32 bodyColor;
	public float BodySize;
	public CutieMark[] CutieMarks;
	public short Eye;
	public Color32 eyeColor;
	public Gender gender;
	public Color32 hairColor0;
	public Color32 hairColor1;
	public short Hoof;
	public Color32 hoofColor;
	public short Mane;
	public string name;
	public LoE.Shared.CharacterType race = LoE.Shared.CharacterType.EarthPony;
	public List<Stat> stats = new List<Stat>();
	public short Tail;

public void OnSerialize(NetOutgoingMessage msg)
{
    msg.Write(this.name);
    msg.Write((byte) this.race);
    msg.Write((byte) this.gender);
    msg.Write(this.CutieMarks[0].ID);
    msg.Write(this.CutieMarks[1].ID);
    msg.Write(this.CutieMarks[2].ID);
    msg.Write(this.hairColor0.RGBBytes());
    msg.Write(this.hairColor1.RGBBytes());
    msg.Write(this.bodyColor.RGBBytes());
    msg.Write(this.eyeColor.RGBBytes());
    msg.Write(this.hoofColor.RGBBytes());
    msg.Write(this.Mane);
    msg.Write(this.Tail);
    msg.Write(this.Eye);
    msg.Write(this.Hoof);
    msg.Write(this.BodySize);
    msg.WriteRangedSingle(this.HornSize, 0f, 2f, 0x10);
}
	
public void OnDeserialize(NetIncomingMessage msg)
{
    this.name = msg.ReadString();
    this.race = (CharacterType) msg.ReadByte();
    this.gender = (Gender) msg.ReadByte();
    this.CutieMarks = (from id in new int[] { msg.ReadInt32(), msg.ReadInt32(), msg.ReadInt32() } select StaticData.CutieMarks[id]).ToArray<CutieMark>();
    this.hairColor0 = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.hairColor1 = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.bodyColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.eyeColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.hoofColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.Mane = msg.ReadInt16();
    this.Tail = msg.ReadInt16();
    this.Eye = msg.ReadInt16();
    this.Hoof = msg.ReadInt16();
    this.BodySize = msg.ReadFloat();
    this.HornSize = msg.ReadRangedSingle(0f, 2f, 0x10);
}
 
PonyData data = data2;
INetSerializable[] args = new INetSerializable[] { new IntSerializer(this.selectedNetCharacter), data };
Net.RPC(1, args);

Character data / ponyData (SunButt) :
46 00 00 b0 01					Header (5)
01 ff ff ff ff 					???? (?> probably RCP stuff)
07 								SunButt string lenght (1)
53 75 6e 42 75 74 74 			SunButt string (7)
03 								Race (1)
02 								Gender (1)
17 00 00 00						CutieMark 1
06 00 00 00						CutieMark 2
00 00 00 00						CutieMark 3
ff cd fd						HairColor 0
80 ff ed						HairColor 1
ff ff e8 						BodyColor
49 d1 ff 						EyeColor
80 ff 80						HoofColor
00 00							Mane
01 00 							Tail
00 00							Eye
00 00							Hoof
00 00 80 3f						BodySize
DF 69                           HornSize


=> Compare if the RCP stuff is always the same with different characters
=> When it's done make a Load/Save character interface that take QByteArrays, then you can read/write those with files

46 00 00 d0 01					Header (5)
01								RCP number (1)
ff ff ff ff						Pony id (4)
0b 50 69 6e 6b6965205461696c0101000000000000000000000000ffff80ff80ff808080ff8080ffff8001000100010000000000803f

=> Le 01 c'est le numero du RPC, c'est ca qu'on check
=> Si on a ff ff ff ff, c'est un nouveau character
=> Sinon c'est l'indice du character dans la liste (en partant de 0)

=> Delete request
46 1a 00 28 00	Header
02 				RCP num
00 00 00 00		Pony id

?> The game probably expected somethign else than sending back the characters list ...

=> Disconnect request (with message at the end)
0x87, 0x00, 0x00, 0x90, 0x00, 
0x11, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 
0x62, 0x79, 0x20, 0x75, 0x73, 0x65, 0x72 };

=> Voir CharacterCreator.DrawBorderAndDescription, the code of the "Play" button is in there, it does more than just saving !
=> When loading a scene as the answer for the Play button we get this exception and then tons od DayAndNight... exceptions

NullReferenceException: Object reference not set to an instance of an object
  at GUIManager.EnableGUI () [0x00000] in <filename unknown>:0 
  at GUIManager.OnEnable () [0x00000] in <filename unknown>:0 
  
 => Find out EXACTLY what the Play button code in CharacterCreator.DrawBorderAndDescription does, then figure out what to send
 
 ==> Dump of known button code
 
if (GUI.Button(new Rect((float) (Screen.width - 60), 5f, 55f, 30f), text) && !isSaving)
{
	<DrawBorderAndDescription>c__AnonStorey14 storey = new <DrawBorderAndDescription>c__AnonStorey14();
	isSaving = true;
	this.SaveCharacter();
	if (<>f__am$cache3A == null)
	{
		<>f__am$cache3A = delegate {};
	}
	storey.joined = <>f__am$cache3A;
	storey.joined = new Action<string>(storey.<>m__1F);
	Net.OnRoomChange = (Action<string>) Delegate.Combine(Net.OnRoomChange, storey.joined);
	if (<>f__am$cache3B == null)
	{
		<>f__am$cache3B = delegate {};
	}
	BusyInfo("Saving character...", <>f__am$cache3B);
}

=> Aucune idee de ce que les Storey font, mais apparement le AnonStorey14 est capable d'activer les inputs (CInput)
==> Make a log when it's called to see if loading a level fires it ?
?> le isSaving sert surement à qqch

=> WHAT ARE THOSE ACTION<STRING> THOU SPEAK OF ?

An Action delegate is put simply an encapsulated method that returns no value, or a void encapsulated method. In this use case, it is acting as a call back that will fire off depending on what the type T is passed in for the System.Action, where T is a boolean variable.
You can use the Action<T> delegate to pass a method as a parameter without explicitly declaring a custom delegate. The encapsulated method must correspond to the method signature that is defined by this delegate. This means that the encapsulated method must have one parameter that is passed to it by value, and it must not return a value. (In C#, the method must return void. In Visual Basic, it must be defined by the SubEnd Sub construct. It can also be a method that returns a value that is ignored.) Typically, such a method is used to perform an operation.
=> All the actions are function-pointer-thingies that you can point to any private static void function and call anytime.
?=> INB4 ACTIONS<> ARE THE MISSING NETWORK COMMANDS!
==> Example of use :
Action<string> messageTarget; 
if (Environment.GetCommandLineArgs().Length > 1)
	messageTarget = ShowWindowsMessage; // A function
else
	messageTarget = Console.WriteLine; // Another function
messageTarget("Hello, World!"); // Call to whatever function is inside the action

=> NOW WHAT ARE THOSE DELEGATE THINGS ?

Ca reference une methode, donc on l'apelle comme un pointeur de fonction
Quand on l'apelle elle lance TOUTE les fonction auquel elle a souscrite.
On peut assigner une unique souscription avec =
On peut soucrire/desouscrire de nouvelles fonctions avec des += et -=
Faire Delegate.Combine souscris au deux arguments de combine seulement, donc invoque les deux quand appelee
See http://forum.unity3d.com/threads/150321-C-delegates-I-love-you first, it explains everything
See http://forum.unity3d.com/threads/119446-proper-use-of-delegates

Exemple :
OnSpawnEnemy = CreateTrolls;
OnSpawnEnemy(4); // 4 trolls
OnSpawnEnemy += CreateTrolls;
OnSpawnEnemy += CreateOrcs;
OnSpawnEnemy(4); // 4 trolls, 4 Orcs
OnSpawnEnemy -= CreateTrolls;
OnSpawnEnemy(4); // 4 Orcs

On peut aussi faire des delegate anonymes, si on les appellent ils executent juste la fonction anynome entre {} example : OnSpawnEnemy = delegate { //stuffToDo } 


=> Donc quand on fait Net.OnRoomChange = foo, c'est la fonction foo qui sera executée au prochain loadLevel !!!!!
==> Ca explique des tonnes de choses ! Il doit y avoir un Net.OnRoomChange qui sert a charger le level normalement !!
===> Chercher tout les Net.OnRoomChange et trouver ceux interressant ! Par exemple ceux qui initialisent ds choses ou qui touchent au personnages

=> So basically the "Play" button code adds storey.<>m_1F(string) to the suscriptions of Net.OnRoomChange, add a log debug to confirm
=> Quand storey.<>m_1F est appellee il apelle CharacterCreator.CloseBusyInfo(), se supprime des delegates de Net.OnRoomChange et appelle CInput.QuickEnable()
=> So storey.<>m_1F is definitely called on loadLevel while saving but maybe the game expected to go back to CharacterSelect or something ?

=> So recap de la fonction quand on clique Play
=>Fait isSaving=true et saveCharacter()
  Souscris storey.<>m_1F a Net.OnRoomChange
===>storey.<>m_1F : apelle CharacterCreator.CloseBusyInfo(), se supprime des delegates de Net.OnRoomChange et appelle CInput.QuickEnable()
=====>CloseBusyInfo() : if infoCloseAction==null return, sinon isSaving = false
      call infoCloseAction(string.Empty), wich is a non null delegate (or else we would have exited)
	  if the delegate noLongerBusy!=null, call noLongerBusy
=====>CInput.QuickEnable() : Set InputControl.alldisabled = false
  Call BusyInfo("Saving character...", <>f__am$cache3B) with <>f__am$cache3B a delegate (that may sometime be anon empty)
====>BusyInfo : Cree une message box info "Please wait","Saving Character"
     souscris infoCloseAction a la command de fermeture de cette message box (will be called in CloseBusyInfo())
	 souscris noLongerBusy au parametre <>f__am$cache3B (will be called in CloseBusyInfo())

=> LIST :
==> Find all subscriptors of <>f__am$cache3B => Toujours anon empty
==> Find all subscriptors of Net.OnRoomChange => just loadLevel et storey.joined (aka <>m_1F)
==> Just to be sure it's nothing, find all subscriptors of <>f__am$cache3A => Toujours anon empty
===> So basically the play button is useless by itself. It just fires a message box and send character data.

=> LIST :
==> Find WHAT IS Awake(),OnEnable(),OnDisable(), how to enable a script AND THE WHOLE monoBehavior STUFF IN UNITY !
===> Enable/Disable a script/object by setting object.enabled=true/false;
===> The order of the four methods of a script related to initialization is always:
	 	Awake()
	 	OnEnable()
	 	OnLevelWasLoaded() // (only on scene changes)
	 	Start()
	 However, if your script was disabled in the first place(via Script.enabled=false), this order changes to:
		 OnLevelWasLoaded() // is now called first, before Awake()! (only on scene changes)
		 Awake()
		 [OnEnable()/Start() are not executed until the script is actually enabled]
==> Find all the NetIncomingMessage (or ReadByte maybe) to find the network data handlers
==> Find who else is calling CInput
==> Find who is calling DayAndNightController
==> Find who is calling GUIManager (and find GUIManager.OnEnable)
==> Find a delegate that loads interesting stuff
==> Find important classes (the private one are almost always called on a special event)

=> GUI.EnbaleGUI() calls a ShowMinimap() function ! If only it worked.
==> Find what causes the exception and what is supposed to be called before EnableGUI to initialise stuff
===> Then find a way to send a network request to initialise this stuff first


====> See DayNightController::LevelLoaded
public static void ApplicationStart()
{
	MonoBehaviours.onLevelWasLoaded = (Action<int>) Delegate.Combine(MonoBehaviours.onLevelWasLoaded, new Action<int>(DayNightController.LevelLoaded));
}

public static void LevelLoaded(int level)
{
	if (((Application.loadedLevelName != "MainMenu") && (Application.loadedLevelName != "Characters")) && (RenderSettings.skybox != null))
	{
		Instance.InitScene();
	}
	else
	{
		Instance.enabled = false;
	}
}

=> See ProcessUtils in PNetU, there might be some interesting RPC actually
==> Like setting the player ID, you probably need to do that at some point
==> Or instantiate objects. Seems like a way to load prefabs in the world, maybe we can load the player's character this way ?
===> Actually one of the parameter of Instantiate is num3 and it's checked against the player id, component.IsMine = PlayerId == num3;
====> First set the player ID to something not too obvious, then instantiate a character somehow and give it the player ID

=> This code is crazy. There is an entire class GameManager with just two arrays onlyActiveInGame/MainMenu and two functions on thoses array
=> Except the arrays are never initialised and never referenced anywhere else. By all rights they should always be empty. But the class is still here.
=> Same for the NetCharController, the localBehaviour array is always empty.
==> But the empty arrays are all public. Maybe they are filled somewhere else but I can't find any references.

=> MonoBehaviours.onLevelWasLoaded = (Action<int>) Delegate.Combine(MonoBehaviours.onLevelWasLoaded, new Action<int>(DayNightController.LevelLoaded));
==> This is why we get tons of DayNightController errors when we forcefully loads a level
==> This means that DayNightController is part of the game starting procedure.
==> Thus if you find who is normally supposed to init DayNightController, you might find other infos about how to properly enter a game
===> Find who is supposed to enable/init DayNightController, what to do to trigger normal behavior, and what happens next

=> ApplyNetworkCharacter() looks like it loads a character ! Try to find a way to invoke it to see what it does.
==> It's called each time there is a GetPonyData()
==> GetPonyData is meant to read only one pony's data, then ApplyNetworkCharacter() will use only this pony's data
==> Inb4 main character selection code
===> Find who sends the RPC request for GetPonyData(), there should be a difference with the normal RPC to get the ponies list

=> Request character list : 480000080006
=> Request at level load : 	480200080006
Well, that was unexpected. RPC for GetPonyData is RPC 200. It's called directly by the "/kick user" command.

=> Maybe you could just make a list of all the functions that take an incoming message as argument and other kinds of RPC stuff.
=> Then see wich one are related with the CharacterCreator, you know that at least the "list ponies" request and "load level" can close the "Saving" message box.
=> List of requests that close the BusyInfo message on the character creator :
==> Load level, loads a different scene, so that's kinda cheating
==> Send ponies, sending the list of ponies just closes the message box
==> Error, close the message box and open an error message box instead

?==> Seems like send ponies is the expected behaviour and error in case of problem, so first close the message box then do something else

=> PlayerId is the OwnerId of the player. When you instantiate objects they get an OwnerId, and if it matches the PlayerId, then IsMine=true 

=> Instantiate loads an asset into the scene. The list of all the ressources per file is in the Ressources folder
?=> To load file.prefab, use "instantiate file". Except the .prefab extension isn't recognised by the ressouce explorer, and I don't know the type id for .prefab
===> Maybe type .43 is .prefab ?

=> From the videos of a game's mod, enter game sequence is "Play"->Saving messagebox->Wait/Freeze->Loading screen->Wait/Freeze->Static view of ponyville, gui disabled (same as the one I get)->Wait/Freeze->View of behind an unknown full red generic character, gui still disabled->Same view but with the proper character (white with brown mane), and GUI loaded fully (chat, minimap, hotbar).
==> So far we've got it right (or almost right given the exceptions in the log) until the scene is loaded. Still need to load character

=> Fun fact : There is a "Singleplayer Mode" thingy in GameManager::Start


- Do the list in the server's widget.cpp
- Remove the wordfilter inside the code. (Patch the function to do nothing)
- Remove the register button, registration is automatic (do a br (jump) when it draws the button)

=> OK SO NOW WE HAVE THE .CAP FILES !!
==> So, this is now reverse engineering general 
=> THERE CAN BE MUTLIPLE MESSAGES IN THE SAME UDP PACKET !
=> YOU CAN HAVE 86 ..... 48 ..... IN THE SAME PACKET !
==> THE PNET READING FUNCTION SHOULD ONLY DELETE THE SIZE THAT WAS READ, NOT THE WHOLE PACKET, THEN PROCESS AGAIN IF SOME DATA IS STILL IN THE BUFFER

===> REVERSING OF : LoE6.cap
1. Connection/PNet handshake 83, 84, 85
2. Pings from both the client/server
3. Server sends a 48 set player id and a 48 to load Characters scene
4. Server sends a 46 with "MLKJ", probably character load list, and twice for some reasons (probably because the ACK was lost)
5. Client sends a 48 06
6. Server sends someone's chat message on 46
7. Another round of pings and chat message from the server on the 46
8. Client send a 46 with "MLKJ", probably character save list
9. Server answers with a 48 to load GemMines (in the same UDP packet than the 86 ack)
10. Another round of pings
11. Server sends two 46 in the same UDP packet. First with the name "Lighning Chaser Kirito93", second is a 46 with 0E 00 00 00 00, probably character list
12. Client sends a 48 06
13. Server sends a huge UDP packet with multiple 48 inside, probably mobs list, contains "Mobs/Timberwolf" and "PlayerBase"
14. Server send two 01 requests in the same UDP packet with 13 and 14 bytes of binary data
15. Client sends a 4D with 07 00 04 and a 48 with 08 07 00
16. Servers sends two 01 again
17. Client sends a 48 with 08 60 00, another with 08 37 00 and another with 08 76 00
18. Server sends two 54 in the same UDP packet, one with "Klondike Hicks", the name of a PNJ
19. Server sends multiple small 54 in the same UDP
20. Server sends a bunch of 54 and 01 again in the same UDP packet (this is wireshark packet 108)
21. Server sends a fuckton of 54 again in 1 packet
22. Server sends two 01 with binary data
23. Server keeps sending more 01 on different UDP packets
24. Client sends a 01 (UDP packet 122)
25. Server sends a 46 contains "Brownie","Best Derped NPC"
26. Server sends a 01 in the same packet
27. Client sends a 4F with 76 00 CA 01 00 00 00
28. Server sends a 01
29. Client sends a 01 (UDP packet 129)
30. Server sends a small 54
31. Client sends another 01
32. Server sends a 01
33. Client sends a 01
34. Server sends a 01
35. They keep on exchanging a fucktons of 01 and acknoledging them on a lot of small UDP packets
36. Client sends a 4F with 76 00 CA 00 00 00 00 (packet 174)
37. They keep on exchanging 01 and the 4F packet is acknoledged, then server sends a 54 in the same packet (packet 186)
38. They keep on exchanging a fucktons of 01 and acknoledging them on a lot of small UDP packets, also a ping round
39. Server sends a 46 contains "Cappy Uni.:" (packet 258)
40. They keep on exchanging a fucktons of 01 and acknoledging them on a lot of small UDP packets, the size of the 01 is often/always 24 or 18 bytes
41. Server sends a 46 contains "Shadow Dreams", "Lol" (packet 373)
42. They keep going with the 01, with pings in the middle, at some point Wireshark mistakenly recognise CIGI protocol (packet 471)
43. The client sends a 87 (disconnect) with message "disconnecting"
44. Client sends a ICMP unreachable to the server

===> REVERSING OF : LoE7, very small capture, only loads GemMines level, wait ~2s and exit game, 308 UDP packets total
1. Connect
2. A round of pings
3. Server sends 48 set player id and 48 load level "Characters" request
4. Server sends 46 players list
5. Server sends 46 chat message
6. Client sends 48 06
7. Client sends player save
8. Server sends 48 load GemMines request
9. Server sends 46 contains "Lighning Chaser","Kirito93" and a 46 E0 00 00 00 00
10. Client sends a 48 06
11. Server sends multiple 48, two of them contains "Mobs/Timberwolf" and another one contains "PlayerBase"
12. They exchange a few 01
13. Client sends a 4D 07 00 04
14. Client sends a 48 08 07 00
15. Exchange a few 01
16. Server ack the 4D and the 48
17. Client sends a 48 08 55 00
18. Server sends a small 54 and a bigger 54 contains "Klondike Hicks"
19. Client sends a 48 08 3C 00 and a 48 08 72 00
20. Server sends four 54
21. Server sends four 54 again
22. Server sends more 54, one contains "MLKJ"
23. Server sends more 54 and a 01
24. Server sends a 46 chat message (packet 105)
25. They exchange more 01 and pings
26. Client sends a 4F 72 00 CA 01 00 00 00
27. Servers ack and sends a 54 72 00 CA 01 00 00 00 (same data that the 4F received)
28. They exchange more 01, mostly sent by the client
29. Client disconnects

=> We often get a message like "Lighning Chaser","Kirito93" when loggin in, that's weird.
==> Not always tho, so it's probably the chat or something

=> LoE11 is pretty clean, you're alone in the room but there are a few 46 messages, probably chat tho
=> LoE12 is very clean too, but you're not alone in the room. I saw another blue guy while playing and there was probably another one too.

?> LoE11 Enter game sequence
Client sends the selected character
Server sends the level to load
Server sends a 46 that appears to be a chat message and two other 46
Client ack the three 46 and sends a 48 06
Server ack the 48 and replies a 48 with "PlayerBase", probably mobs/players list
Client ack the 48 and send a 48 08 85 00, the data of the 08 may be different, but should be 08 XX 00
Server ack the 48 and sends multiple 54, one of them contains "Mud Orange", the name of the character selected
Client ack them
Serer sends some more 54
Client ack them too
Then they start exchanging some 01 before the client's disconnection, the first 01 is probably the end of the enter game sequence and start of the sync

=> Copy the login sequence in LoE11 exactly into the private server then see what it does
=> Well maybe I did it wrong but it's not working.
==> Let's try to understand what the game is doing with the packets we send

=> The 48 "PlayerBase" and "Mob/Timberwolf" messages first
==> Format of the Instantiate message :
1 Message Type (48)
4 Header
1 Util type (1)
X String (Key)
2 Uint16 (ViewId)
2 Uint16 (OwnerId)
Vector
Quaternion

Example :
01 Util type
0a String size
50 6c 61 79 65 72 42 61 73 65 String (PlayerBase)
85 00 ViewId
64 00 OwnerId
7f 45 fd 41 be 21 95 bf 3e 0e 6a c2 Vector
00 00 00 00 fd 98 7e bf 00 00 00 00 0f 13 d6 3d Quaternion

===> I FORGOT TO SEND THE 48 04 TO SET THE PLAYER ID ! IT WAS HIDDEN IN THE SAME PACKET AS A CHAT MESSAGE (Packet 37 in LoE11)

?> Content of the 01 sync messages

01 76 02 98 00 Header
85 00 Player id
4b 14 d7 41 Time
6a 0a db 41 Pos.x
bf 21 95 bf Pos.y
70 c8 61 c2 Pos.z
70 Rot.y

msg.WriteTime(false);
new Vector3Serializer(this._transform.position).OnSerialize(msg);
Vector3 vector = this._transform.rotation.QuatToEul2();
if (this.XZRotationSynchronization)
{
	msg.WriteRangedSingle(vector.x, -6.283185f, 6.283185f, 8);
	msg.WriteRangedSingle(vector.y, -6.283185f, 6.283185f, 8);
	msg.WriteRangedSingle(vector.z, -6.283185f, 6.283185f, 8);
}
else
{
	msg.WriteRangedSingle(vector.y, -6.283185f, 6.283185f, 8);
}

Vector3Serializer writes 3 floats
WriteTime(false) writes the time as a float (4 bytes)
WriteRangedSingle writes 1 byte here

=> Now when we walk into a teleported we get a message on 56, for example : 56 02 00 18 00 01 00 01 for Carousel boutique's interior
==> Need to test from another location, like from the GemMines to Ponyville to see if the data is the global Id of the map to load or a map-relative teleporter Id
===> Maybe search the messages starting by 56 in wireshark (data[0]==56)

=> The message 54 calls a given view's RPC
NetworkView view3;
ushort id = msg.ReadUInt16();
byte rpcID = msg.ReadByte();
if (NetworkView.Find(id, out view3))
{
	view3.CallRPC(rpcID, msg);
}

=> All the 54 we send in LoE11 are to the view id 0085, wich is registered by us
==> Find all the register functions and find id 0085
===> The view id is the id of a view we registered before. Network view are instantiated/registered by the server's requests
===> The view 0085 was the "PlayerBase"
?===> PlayerBase and its associated methods/actions might be all defined in a unity ressource file
====> Go analyze the function that instantiate NetworkViews to see if it registers the RPC or something
====> Or just see the function that find the unity ressource file and find the RPC functions
=====> Can't see the unity function that loads ressources in the C# code, it must be regular ASM, let's just finish the rest first

=> The server sends 1 unique player ID per connected player, ID from disconnected players should be reused
?> It also sends 1 unique view ID per entity. An entity can be a player or a NPC
==> We should transform the Player structure into a Character structure that includes NPC, then add a "player" bool that is false for NPCs
==> Add sendNetviewInstantiate/sendNetviewRPC and such functions to clean the netcode. Rename list entities/send entities list to something apropriate
==> Create a character class and make player a class inheriting from character. Only player have socket infos and stuff
==> Then when sockets are needed request a player and when only positions are needed request a character. Add some methods like resetPlayer

=> Implement automated game start using the player infos.
==> Those are the main static methods. The commented line are not necessary but I don't know what they do yet (one of them could be a cam quaternion)
void sendEntitiesList(Player& player)
{
    if (!player.inGame)
    {
        sendPonies(player);
        player.inGame=true;
        return;
    }

    // Send the entities list if the game is starting (register the view "PlayerBase" with id 0085)
    win.logMessage(QString("UDP : Sending entities list"));
    sendMessage(player,MsgUserReliableOrdered6,QByteArray::fromHex("010a506c6179657242617365850064007f45fd41be2195bf3e0e6ac200000000fd987ebf000000000f13d63d")); // Sends a 48
}

void sendEntitiesList2(Player& player)
{
    // Send the entities list if the game is starting (sends RPC calls to the view with id 0085 (the PlayerBase))
    win.logMessage(QString("UDP : Sending entities list 2"));
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850033000000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850032000000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850033010000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850032010000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("8500c80a4d7564204f72616e676503034b000000000000000000000080c6ff9fd4fff2ff80df80ff85bf3401000900010000002e55693fdf69")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("8500050c0020000a000000")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("8500c30300000000000000ffffff7f01000000ffffff7f05000000ffffff7f")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850032000000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850033000000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850032010000c842")); // Sends a 54
    //sendMessage(player,MsgUserReliableOrdered18,QByteArray::fromHex("850033010000c842")); // Sends a 54
}

=> Understanding the small 54s
=> They are used to set a player's current/max stats
=> 0x33 is for Max and 0x32 for Current
850033000000c842
850032000000c842
850033010000c842
850032010000c842

85 00           View ID (2)
33              RPC ID (1)
00              Stat ID (1)
00 00 c8 42     Stat Value (float) (4)

=> Reverse of the medium sized 54s
=> It sets the inventory of the player.
==> There is probably a buffer overflow vulnerability here. For example if an Item's Index>MaxSize.
===> There isn't. C# does bounds checking at runtime and PNet will catch everything.


Inventory (example with an empty one
85 00           View ID (2)
05              RPC ID (1)
0c              MaxSize (1)
00              Size (1)
... Inventory items (9*Size)
20              WornMaxSize (1)
00              WornSize (1)
... Worn inventory items (5*WornSize)
0a 00 00 00     Bits (4)

Inventory Items (example that I made up)
01              Index (1)
01 00 00 00     ItemID (4)
02 00 00 00     Amount (4)

Worn Inventory Items (example that I made up)
01              Index (1)
01 00 00 00     ItemID (4)

public void OnDeserialize(NetIncomingMessage message)
{
    this.MaxSize = message.ReadByte();
    byte num = message.ReadByte();
    this.Items = new InventoryItem[this.MaxSize];
    for (int i = 0; i < num; i++)
    {
        InventoryItem item = new InventoryItem();
        byte index = message.ReadByte();
        item.OnDeserialize(message);
        this.Items[index] = item;
    }
    ItemArraySerializer serializer = new ItemArraySerializer();
    serializer.OnDeserialize(message);
    this.WornItems = serializer.Items;
    this.Bits = message.ReadInt32();
}

=> Reversing of the last long 54
=> It's used to set the player's skills
==> OLD MESSAGE
8500c30300000000000000ffffff7f01000000ffffff7f05000000ffffff7f
85 00           View ID (2)
c3              RPC ID (1)
03 00 00 00     Capacity (4)
00 00 00 00     SkillID 1
ff ff ff 7f     SkillLevelDef 1
01 00 00 00     SkillID 2
ff ff ff 7f     SkillLevelDef 2
05 00 00 00     SkillID3
ff ff ff 7f     SkillLevelDef3
==> NEW MESSAGE
c3 				RPC ID (1)
00 				Use dictionnary flag (1)
02000000		Capacity (4)
0a000000		SkillID 1
00000000		SkillLevelDef 1
0b000000		SkillID 2
00000000		SkillLevelDef 2

=> Turns out the 46 messages might not have been juts chat. We're still missing the skills bar and the rest of the GUI.

=> Reversing the first 46
=> This one is a chat message (received)
0f2a4262ae5248d048040000000a50696e6b696520506f6509616e64206f74686572a009000000
0f                                  RPC ID (1)
2a 42 62 ae 52 48 d0 48             Time (8)
04 00 00 00                         ChatType (4)
0a 50 69 6e 6b 69 65 20 50 6f 65    Name (len+String)
09 61 6e 64 20 6f 74 68 65 72       Text (len+String)
a0 09 00 00                         CharacterId (4)
00                                  AccessLevel (1)

=> Another received chat message
46 10 00 70 01 
0f 
04 
0c 43 6f 6c 65 20 50 6f 6b 65 6d 6f 6e 
19 4d 79 20 73 6b 79 70 65 3a 20 63 6f 6c 65 2c 6d 61 63 69 6e 74 72 79 65 31 
e1 1a 00 00 
00

=> Other chat message (sent)
46 04 00 50 00						Header
0f 									RPC ID (1)
04 									Chat type (4)
07 									String length
41 41 41 41 41 41 41				String


=> Reversing the second 46
=> Calls ProcessGroupRPC to add friends
141500000000
14              RPC ID (1)
15              MagicNumber (always 0x15) (1)
00 00 00 00     nFriends

=> Reversing the third 46
=> Calls ProcessJournal to add journal entries
0e00000000
0e              RPC ID (1)
00 00 00 00     nEntries
01 65           Text1 (String)           
01 65           Text2 (String)

=> Find the procedure to load another scene with a vortex in the Cap files. Search for the vortex's ID
==> In LoE2 (Big), packet 14317 client sends 56  00 00 18 00  03 00 01
==> At 14326 the server ACK the 56 message
==> At 14328 the server sends 481c0058000509506f6e7956696c6c65 (contains the string PonyVille) and  46540008000d (RPC 0x0D - EndDialog)
==> Then the client is busy loading and nothing happens for some time except pings and chat messages
==> At 14416 the client sends 48 16 00 08 00 06
==> Then the server starts sending fucktons of messages containing "PlayerBase" at 14419, 14421 and 14423
===> 14419
48 1e00 6001 010a506c6179657242617365080000004cb71a42254643c3e72bca43000000001058393f00000000d7a330bf
48 2000 6001 010a506c617965724261736509000000ee7c72c2bc7441c3b4a8014300000000560e0d3f000000000681553f
48 2200 6001 010a506c61796572426173650a00000004f65cc30e4d43c310182a430000000096436b3f00000000713dcabe
48 2400 6001 010a506c61796572426173650b00000098ee9842254643c36aacaf4300000000b6f31d3f00000000d578493f
48 2600 6001 010a506c61796572426173650c000000f8d35ec3773e43c3cb418243000000001f852b3f00000000b6f33d3f
48 2800 6001 010a506c61796572426173650d00000014ae2f40984e43c3acdc5b4300000000e5d0623f00000000560eedbe
48 2a00 6001 010a506c61796572426173650e000000cdec69c3d34d43c35c8f234300000000a245363f0000000046b6333f
48 2c00 6001 010a506c61796572426173650f000000b81e1fc1d34d43c3b4e85f43000000001b2f5d3f000000002506013f
48 2e00 6001 010a506c6179657242617365100000002db272c3d34d43c3c1ea2843000000000c022b3f0000000052b83e3f
48 3000 6001 010a506c617965724261736511000000000000c1bf4d43c30000aa430000000000000000000000000000803f
48 3200 4801 0107546573744d6f621200000000000000000000000000000000000000000000000000000000000000
48 3400 6001 010a506c6179657242617365130000002dd20fc3773e43c38f529643000000001283203f000000008b6c473f
48 3600 6001 010a506c617965724261736514000000355e48421bef2dc329dc524200000000f6281c3f0000000083c04a3f
48 3800 6001 010a506c6179657242617365150000009a1952421bef2dc35c0f554200000000b072483f00000000643b1fbf
48 3a00 6001 010a506c617965724261736516000000f6283cc0d3ad42c3a63b434300000000a4703d3e00000000e3a57b3f
48 3c00 6001 010a506c617965724261736560006e0007d4d3c14e4d43c390991544000000009166b03d00000000720c7f3f
48 3e00 6001 010a506c617965724261736546005400f0d10d40524e43c32bd455430000000008590abe000000001ea77d3f
48 4000 6001 010a506c61796572426173654000780028ea5dc3834d43c3758a29430000000065d849bc0000000007fb7f3f
48 4200 6001 010a506c617965724261736545005a00bf0fc1c24b5b3cc3c3b84143000000009578cabe00000000f7216b3f
48 4400 6001 010a506c61796572426173659f002b00bad576c2d54d43c3ddd4534300000000501f2a3f00000000ef4b3f3f
48 4600 6001 010a506c61796572426173656e002a0066e671c3a54e43c39a991f430000000045c4063f00000000d3a7593f
48 4800 6001 010a506c61796572426173655a006200fa176ec3774e43c32c542f4300000000da8c663f00000000e68dde3e
48 4a00 6001 010a506c617965724261736574000a0052e13342a5052fc3160a7143000000009578cabe00000000f7216b3f
48 4c00 6001 010a506c6179657242617365510061008259e8c09eb240c353cba84300000000e17144bf000000008e26243f
48 4e00 6001 010a506c61796572426173658f006700d52c1ac35d4b43c3630ff44200000000af836dbe00000000b804793f
48 5000 6001 010a506c617965724261736559001600c2932443a0449ac2ae492a4400000000256179bf00000000cb5f673e
48 5200 6001 010a506c6179657242617365480009008d229942da5043c3f0c3af430000000014590a3e000000001ea77d3f
48 5400 6001 010a506c617965724261736573001f00acf11442194e43c30b45c84300000000c2fe7fbf000000004ed9c93b

===> 14423
Type Header Header Data
48 6e00 6001 010a506c6179657242617365a70055006fb486c295cf3dc396229543000000008a5b25bf00000000126e433f
48 7000 6001 010a506c61796572426173657c005c0066e670c3333343c39a991f430000000045c4063f00000000d3a7593f
48 7200 6001 010a506c61796572426173657500170070416bc317643ac38a85924300000000db4a4cbf0000000044461a3f
48 7400 6001 010a506c6179657242617365420007002a5eeec25a7535c3bdaf9a430000000049277cbd00000000b3837f3f
48 7600 6001 010a506c61796572426173654c006a007ec936c3a04d43c37fe4c34300000000ebe07fbf00000000f245fc3c
48 7800 6001 010a506c6179657242617365650076006b8dbabf7d3043c3cf90444300000000509b7f3f000000000ef7623d
48 7a00 6001 010a506c61796572426173657700190054da82c24c4e43c3d7764f43000000008c5b253f00000000106e433f
48 7c00 6001 010a506c61796572426173657b002900d76a57c3c64f43c32d4e2d4300000000dd4a4c3f0000000041461a3f
48 7e00 6001 010a506c61796572426173655c004a00a572e040daef2dc33c12374200000000cc1e3cbf00000000d2a02d3f
48 8000 6001 010a506c61796572426173657f0079006e341c40340f3fc34b5b494300000000eec960bf000000007afff43e
48 8200 6001 010a506c61796572426173656f005300a28a01c2364e43c31b320a4400000000a65a173d000000003ed37f3f
48 8400 6001 010a506c6179657242617365680063006968994240a83bc344368043000000006af87c3f00000000ac121d3e
48 8600 6001 010a506c61796572426173657900180017bb4d42a1ee2dc3ffd4574200000000353a76bf000000008e1d8c3e
48 8800 6001 010a506c617965724261736571001e0082e499c2f6153fc358f8964300000000346d74bf00000000ac34983e
48 8a00 6001 010a506c617965724261736534005700a2e41bc2b53c3cc3d412ea430000000065d849bc0000000007fb7f3f
48 8c00 6001 010a506c61796572426173653a003800f7de77c24cb841c3ac6396430000000077c06bbf000000000392c73e
48 8e00 6001 010a506c617965724261736586004c00f9665bc3f94c43c35f9f094300000000a65a173d000000003ed37f3f
48 9000 6001 010a506c617965724261736576004400382909c2c7123cc3859905440000000049277cbd00000000b3837f3f
48 9200 6001 010a506c61796572426173658000420004963d42b8aa32c39ef49f4200000000fd987e3f00000000ef12d63d
48 9400 6001 010a506c6179657242617365630047009f7298c33c4d43c3153f5f4300000000cc56333f0000000026af363f
48 9600 6001 010a506c61796572426173658a002600c91c98c3224d43c3766b5f4300000000cc56333f0000000026af363f
48 9800 6001 010a506c6179657242617365840036000000f0c1cd4c42c300c019440000000065d849bc0000000007fb7f3f
48 9a00 6001 010a506c617965724261736582000300cd4c08c366e642c39a19c143000000000000803f0000000000000000
01 6002 7800 7500bd880946f473823b008f7f5a7f
01 6202 7800 a700ee8809468c7c423b448f7f637f
01 6402 6800 71000a8909460e7c2a3b758f4c
01 6602 7800 7300218a0946e781db3a81947f407f
01 6802 6800 3b00f28809465f83153b3e8c8f
01 6a02 6800 6300188909466970db3a6d8b9f
01 6c02 7800 6a001a8909468d7a953bf2887f447f
01 6e02 6800 8000608909466e82133c1584bb
01 7002 6800 4c0046890946a376db3a0e9441
01 7202 7800 a10031890946757f3d3bd1a07f4c7f
01 7402 6800 6d0009890946517b653bad8c75
01 7602 6800 a0003d890946b185f53ae78cb3
01 7802 6800 6f001b890946577edb3a4c9c81

==> At 14425 the server sends some 54s
Type Header Header RPCID Data
54 6a02 4000 3400 320135cd9641
54 6c02 4000 3b00 3201c5a9af42
54 6e02 4000 4200 3201b10eaf42
54 7002 4000 4500 32015097db42
54 7202 4000 4c00 3201248ed142
54 7402 4000 6800 320102594642
54 7602 4000 6a00 320144159742
54 7802 4000 7300 3201a59f9e42
54 7a02 4000 7700 32011597bc42
54 7c02 4000 7900 3201c0035642
54 7e02 4000 7b00 32010589cc42
54 8002 4000 8000 3201d58a1b42
54 8202 4000 a000 3201248ed142
01 7a02 7800 4200 4c890946e579de3bd68f7f7d7f
01 7c02 7800 7600 318909463d7e623b649b7f7d7f
01 7e02 6800 5c00 4b89094652806b3c56825e
01 8002 6800 7700 30890946a57cdb3a9e8a9c
01 8202 6800 4500 20890946097b5e3bef896f
01 8402 6800 8700 488909461276d93ad68174

=> Sometimes load works, often it works with GemMines but not with RaritysBoutique or PonyVille
===> Redoing instantiate + loadPonyData manually after load Everfree1 fixed the failed load. Maybe we should try again until we gain confirmation ?
====> Fixed by the sequence number bugfix

=> Replay of LoE11 instantiate sequence
=> Client selected character, server sent scene (RaritysBoutique)
=> 76 ref, client sends 48 06
=> 79 +0.15s, server sends PlayerBase
=> 81 ref, client sends 48 08 85 00
=> 82 +0.14s, server sends 54 messages
=> 84 +0.16s, server sends more 54 messages
=> End of sequence, start exchanging some 01s

=> 82 
86 0000 1800 480200 
54 0000 4000 8500 33000000c842
54 0200 4000 8500 32000000c842
54 0400 4000 8500 33010000c842
54 0600 4000 8500 32010000c842
54 0800 c801 8500 c80a4d7564204f72616e676501034b000000000000000000000080c6ff9fd4fff2ff80df80ff85bf3401000900010000002e55693fdf69

=> 84
54 0a00 5800 8500 050c0020000a000000
54 0c00 f800 8500 c30300000000000000ffffff7f01000000ffffff7f05000000ffffff7f
54 0e00 4000 8500 32000000c842
54 1000 4000 8500 33000000c842
54 1200 4000 8500 32010000c842
54 1400 4000 8500 33010000c842

=> We have a problem. When you use sendMessage with an outdated Player& you can end up sending different messages with the same ID, and only the first one will be received. We need to refresh the sequence number before sending messages
==> Fixed by using a direct refreshed reference for sequence number I/O

Vortexes list. The position is approximately were the vortex is supposed to send you. 
LoadSpawn is the where you should land if you load this scene with the server console.
==> Vortexes from PonyVille (LoadSpawn : x=-3.80378, y=-195.301, z=176.69)
0a 00 01 RaritysBoutique x=29.5463, y=-1.16745, z=-60.4687
09 00 01 Twilight's Library
14 00 01 SugarCubeCorner x=6.83888, y=-0.0569049, z=1.99048
02 00 01 GemMines x=45.0536, y=9.17758, z=-58.3287
04 00 01 Everfree1 ? x=414.643, y=-0.484952, z=-12.4265
08 00 01 SweetAppleAcres ?  x=59.9794, y=-110.121, z=55.7187
03 00 01 Canterlot -57.108 9.66022 -182.363

==> Vortexes from GemMines (LoadSpawn : x=45.0536, y=9.17758, z=-58.3287)
03 00 01 PonyVille  x=-135.361, y=-195.303, z=380.023

==> Voertexes from Everfree1 (LoadSpawn : x=414.643, y=-0.484952, z=-12.4265)
02 00 01 PonyVille x=-211.408, y=-195.303, z=83.3914

=> Vortexes from SweetAppleAcres (LoadSpawn : x=59.9794, y=-110.121, z=55.7187)
02 00 01 PonyVille x=-321.083, y=-195.303, z=223.741

=> Vortexes from Tartarus (LoadSpawn : x=1768.52, y=612.011, z=1031.54)
02 00 01 ???

=> Vortexes from Canterlot (LoadSpawn : x=-32.4926, y=-194.285, z=615.316)
01 00 01 PonyVille x=-32.4209, y=-194.285, z=615.524

=> Vortexes from SugarCubeCorner (LoadSpawn : x=6.83888, y=-0.0569049, z=1.99048)
02 00 01 PonyVille x=-4.76804, y=-195.303, z=346.021

=> Vortexes from RaritysBoutique (LoadSpawn : x=29.5463, y=-1.16745, z=-60.4687)
01 00 01 PonyVille x=51.3338, y=-173.934, z=53.5291

=> Fix the bug that makes the GUI/Chat/Skillsbar invisible. It worked yesterday when I was using the Orange Mud static data.
==> On a screenshot at 21:24 yesterday the GUI workded. But when reusing the server compiled at 21:15 it's not working now.
==> Maybe the GUI only works when we're connected to Internet ?
===> Confirmed ! It only works when connected to Internet for some reason. Maybe a DLL hack could prevent this.
====> Find the exact reason that makes Internet mandatory to enable the GUI (is it the DayNight thingy ?).

=> Create a Vortex database, for each Scene name it must give the default spawn point and all the vortexes with their destination rot/pos
==> The spawn is always id 00 (unless it is possible to have a real vortex with id 00) and is the name of the .dat
==> Create two load functions, one that send to the default spawn and one that lets you choose the destination pos/rot
==> Then when called load refers to the database to find the default spawn, and when taking a vortex to load the right place
===> Start testing with PonyVille.dat

=> You assign IDs and NetviewIDs starting from 1, using unique numbers.
=> Create a Level database, for each level it must give a list of entities (mobs/npc) with their positions
=> Create a NPC database, for each NPC it must give it's ponyData and possible interactions (unless they alreasy are in the client side)
=> Fix the bug that prevents to disconnect/logout from the ingame menu.
=> Implement Rot

=> Implement multiplayer
==> In a new thread for each scene refresh each player, make a list of sync messages for each scene, then send the message to all players for each scene.
==> Don't sync players if they are not inGame or if they are loading.
==> In the new thread, loop as long as the server is running. If the syncing takes less than X ms then sleep for the remaining time.
==> It's unreliable UDP messages so you don't care if they are lost. Just keep syncing.
==> It might cause packet loss on the reliable channels if we spam sync messages tho. You might want to implement PNet reliability on the other channels.

=> 01 sync message
01 7c02 7800 7600 318909463d7e623b649b7f7d7f
01 7e02 6800 5c00 4b89094652806b3c56825e

=> Either use ranged singles like this, smaller but you need to know the map's x/y/z bounds or send full vectors
=> Ranged singles with XYZ rotation sync
76 00 netview id (2)
31 89 09 46 Time (4)
3d 7e X
62 3b Y
64 9b Z
7f RX
7d RY
7f RZ

=> Full vectors with XYZ rotation sync
76 00 netview id (2)
31 89 09 46 Time (4)
3d 7e 54 21 X
62 3b 3a b4 Y
64 9b 67 d1 Z
7f RX
7d RY
7f RZ

=> Apparently the bounds are always the same
public static readonly Bounds DefaultBounds = new Bounds(new Vector3(0f, 750f, 0f), new Vector3(5000f, 3500f, 5000f));
public Bounds(Vector3 center, Vector3 size)
{
    this.m_Center = center;
    this.m_Extents = (Vector3) (size * 0.5f);
}
public Vector3 min{get{return (this.center - this.extents);}}
public Vector3 max{get{return (this.center + this.extents);}}
=> So the static min and max values are
min = (0,750,0) - (2500,1750,2500) = (-2500,-1000,-2500)
max = (0,750,0) + (2500,1750,2500) = (2500,2500,2500)

=> The X/Y/Z vector values are read/written using
msg.ReadRangedSingle(this.roomBounds.min.x, this.roomBounds.max.x, 0x10)
public float ReadRangedSingle(float min, float max, int numberOfBits)
{
    float num = max - min;
    int num2 = (((int) 1) << numberOfBits) - 1;
    float num3 = this.ReadUInt32(numberOfBits);
    float num4 = num3 / ((float) num2);
    return (min + (num4 * num));
}
public void WriteRangedSingle(float value, float min, float max, int numberOfBits)
{
    float num = max - min;
    float num2 = (value - min) / num;
    int num3 = (((int) 1) << numberOfBits) - 1;
    this.Write((uint) (num3 * num2), numberOfBits);
}

=> Fix that fucking bug that instantiate multiple yous, maybe fixing PNet would help
=> Add a lastReceived field containing a PNet sequence number in the player to prevent receiving old packets twice. Basically reject all packets with a seq number older than lastRecevied. Or maybe you can just use the current seq number table for both I/O ? Check this.
=> The server can only provide 65536 IDs before running out. Set the ID per scene and change it each scene load.
=> Fix the entities list code. It's spawning clones instead of different ponies. Use LoE cap with another in room.
=> The sync messages are apparently fucking with the multiplayer and making clones
=> When someone loads a scene, instantiate him for all the other players in the scene

=> (Manual) syncing (may) do nothing at first but at some point the other player becomes a clone.
Sending sync data :010d0078000100147ec94349000e00110057cef9
Syncing 1 to 2
Sending sync data :010d00780002000080c9435b000e003f007fce7f
Syncing 2 to 1

01 0d00 7800 0100 147ec943 4900 0e00 1100 57 ce f9
01 0d00 7800 0200 0080c943 5b00 0e00 3f00 7f ce 7f
=> Compare with the sync messages in LoE12 to see the difference. This is really weird.
==> Replay of LoE12
==> Player id is 5C00, netview id is 7000
===> I removed the 01s, since they are just pos sync messages
8 : Set player id to 5C00
22 : load level
39 : Client sends 48 06 // Client finished loading room (= asks for entity list?)
41 : Server instantiates the 3 PlayerBase // Instantiate the PlayerBases
48 0600 6001 010a506c6179657242617365 7300 7500 2777d741b286dd3f1ae981c20000000065d849bc0000000007fb7f3f
48 0800 6001 010a506c6179657242617365 3700 2700 c425d94122b195bfaf1872c20000000049277cbd00000000b3837f3f
48 0a00 6001 010a506c6179657242617365 7000 5c00 7f45fd41be2195bf3e0e6ac200000000fd987ebf000000000f13d63d // Our client
43 : Server sends a 54 32 to 7300
45 : Server sends more 54s // Set stats immediatly of 7000 (us). Also update stat n°01 of 7300
54 0200 4000 7300 32018de0fc41 // 7300 was probably slowly healing, that'd be why we get a stat update every couple packets
54 0400 4000 7000 33000000c842
54 0600 4000 7000 32000000c842
54 0800 4000 7000 33010000c842
54 0a00 4000 7000 32010000c842
54 0c00 4000 7000 33000000c842
54 0e00 4000 7000 32000000c842
54 1000 4000 7000 33010000fa42
54 1200 4000 7000 32010000fa42
47 : Server sends more 54s // Update stat n°01 of 7300
54 1400 4000 7300 3201848efe41
54 1600 4000 7300 32014e290042
51 : Client sends a 4D and a 48 08 (ACK'd in 58 !) // Send 48 and 4D about id 7300 (request savegame?)
4d 0000 1800 7300 04
48 0400 1800 08 7300
52 : Server sends another 54 // Update stat n°01 of 7300
54 1800 4000 7300 3201e2320142
54 : Client sends another 4d and 48 08 // Send 48 and 4D about id 3700 (request savegame)
4d 0200 1800 3700 04
48 0600 1800 08 3700
55 : Server sends another 54 //  Update stat n°01 of 7300
54 1a00 4000 7300 3201c5320242
57 : Client sends another 48 // Send 48 08 (finished instantiate) about id 7000 (us)
48 0800 1800 08 7000
58 : Server acks the 4d and the 48 from 51 (that were about it 7300):
59 : Server // Send savegame of 7300
54 1c00 4000 7300 320117200342
54 1e00 a000 7300 04200307150000000a3a0000001e3b000000
54 2000 4000 7300 33000000c842
54 2200 4000 7300 32000000c842
54 2400 4000 7300 33010000c842
54 2600 4000 7300 320117200342
54 2800 0002 7300 c8 115a6f726f61726b20426c61636b686f6c6502034200000000000000000000002800ffff9fb6000000ff140092958e03000500010000003322823fe477
61 : Server
86 0000 3000 4d0100480300 // Ack the 4D and the 48 from packet 54 (that was about 3700), send savegame of 3700
54 2a00 4000 7300 32016e280442 //  Update stat n°01 of 7300
54 2c00 2800 3700 04 2000
54 2e00 4000 3700 33000000c842
54 3000 4000 3700 32000000c842
54 3200 4000 3700 33010000c842
54 3400 4000 3700 32010000c842
54 3600 c801 3700 c8 0a53696c76657220437574 0300 6400 000001000000000000000015ff2300ff6f6b69ff0000bb8f0064000100000000004356873fdf9f
63 : Client
48 0800 1800 08 7000 // Send 48 08 (finished instantiate) about id 7000 (us)
64 : Server // RETRANSMISSION of packets 59 and 61 (same sequence numbers)
54 1c00 4000 7300 320117200342
54 1e00 a000 7300 04200307150000000a3a0000001e3b000000
54 2000 4000 7300 33000000c842
54 2200 4000 7300 32000000c842
54 2400 4000 7300 33010000c842
54 2600 4000 7300 320117200342
54 2800 0002 7300 c8 115a6f726f61726b20426c61636b686f6c6502034200000000000000000000002800ffff9fb6000000ff140092958e03000500010000003322823fe477
54 2a00 4000 7300 32016e280442 
54 2c00 2800 3700 042000
54 2e00 4000 3700 33000000c842
54 3000 4000 3700 32000000c842
54 3200 4000 3700 33010000c842
54 3400 4000 3700 32010000c842
54 3600 c801 3700 c8 0a53696c7665722043757403006400000001000000000000000015ff2300ff6f6b69ff0000bb8f0064000100000000004356873fdf9f
54 3800 4000 7300 3201b1150542
67 : Server
54 3a00 4000 7300 3201bd5b0c42
54 3c00 4000 7000 33000000c842
54 3e00 4000 7000 32000000c842
54 4000 4000 7000 33010000fa42
54 4200 4000 7000 32010000fa42
54 4400 c801 7000 c8 0a4d7564204f72616e676501034b000000000000000000000080c6ff9fd4fff2ff80df80ff85bf3401000900010000002e55693fcf69
68 : Server sends sync messages
70 : Server
54 4600 4000 7300 320193320d42
54 4800 5800 7000 050c0020000a000000
54 4a00 f800 7000 c30300000000000000ffffff7f01000000ffffff7f05000000ffffff7f7
54 4c00 4000 7000 32000000c842
54 4e00 4000 7000 33000000c842
54 5000 4000 7000 32010000c842
54 5200 4000 7000 33010000c842
72 : Server	// From now on, just update stat n°01 of 7300
54 5400 4000 7300 32013f340e42
74 : Server
54 5600 4000 7300 32019c320f42
76 : Server
54 5800 4000 7300 32019e091042
78 : Server
54 5a00 4000 7300 3201af091142
80 : Server
54 5c00 4000 7300 320192091242
83 : Server
54 5e00 4000 7300 3201fbea1242
85 : Server
54 6000 4000 7300 3201cbea1342
87 : Server
54 6200 4000 7300 3201cbea1442
...

=> The base64 ponyData ponycode of ML KJ is v/9b/beD4f+f/v3jAwAADAAAgAsAACDylMAfMzPFH3PxyQQ=
=> PonyCode of Big Mac (huuge mac) (b&able offense, for lagging the game) is /Tug/IcA/Ovo2P2Df3mrJQAEgAsAAGZAZPYgwy/Dnw0xfBMQAA==
0 earth pony : 	AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzM7OfZmamHw==
0 unicorn : 	AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzM7OfZmamHw==
0 pegasus :		AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAzM7OfZmamHw==

=> Chat messages sent by a client
Data received (UDP) (hex) : 
46020058000f04000000054141414141
Data received (UDP) (hex) : 
46040058000f04000000054242424242
Data received (UDP) (hex) : 
46060058000f04000000054343434343
Data received (UDP) (hex) : 
46080048000f0400000003414243

46 0800 4800 PNet Header (5)
0f04 00 00 00 03 ??? + Text size 
414243 Text

=> Fix this fucking bug where having two clients can make the second one ping timeout client-side for no fucking reason.
==> Is it because the two players are on the same account ?

=> Log for a normal session (singleplayer)
Reading config file ...
Loaded 21 vortex in 9 scenes
Starting TCP login server ...
Starting UDP game server ...
Loading players database ...
Got 5 players in database
Server started
TCP: New client connected
TCP: Session closed by client
TCP: Received non-HTTP request
TCP: Client disconnected
TCP: New client connected
TCP: Login request received :
IP : 127.0.0.1
Username : tux3
Passhash : efc8ed71e9d9f3039f06d43133ded18579dd31d5
TCP: Login successful, sending servers list
TCP: Client disconnected
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 1/1
UDP: Sending characters data to 1
UDP: Saving ponies for 1 (tux3)
UDP: Loading scene "RaritysBoutique" to 1
UDP: Sending the 46 init messages
UDP: Sending entities list to 1
UDP: Send instantiate for 1 to 1
UDP: Sending pony save to 1
UDP: Sending the ponyData for/to 1

==> Log of a session where the ping timeout bug happened.
TCP: New client connected
TCP: Login request received :
IP : 127.0.0.1
Username : tux3
Passhash : efc8ed71e9d9f3039f06d43133ded18579dd31d5
TCP: Login successful, sending servers list
TCP: Client disconnected
TCP: New client connected
TCP: Login request received :
IP : 127.0.0.1
Username : tux3
Passhash : efc8ed71e9d9f3039f06d43133ded18579dd31d5
TCP: Login successful, sending servers list
TCP: Client disconnected
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 4/4
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 5/5
UDP: Sending characters data to 4
UDP: Sending characters data to 5
UDP: Saving ponies for 4 (tux3)
UDP: Loading scene "RaritysBoutique" to 4
UDP: Sending the 46 init messages
UDP: Saving ponies for 5 (tux3)
UDP: Loading scene "RaritysBoutique" to 5
UDP: Send instantiate for 5 to 4
UDP: Sending the 46 init messages
UDP: Sending entities list to 4
UDP: Send instantiate for 4 to 4
UDP: Send instantiate for 5 to 4    ### Instantiated twice
UDP: Sending pony save for 5 to 5
UDP: Sending the ponyData for 5 to 4
UDP: Sending pony save to 4
UDP: Sending the ponyData for/to 4
UDP: Sending entities list to 5
UDP: Send instantiate for 4 to 5
UDP: Send instantiate for 5 to 5
UDP: Sending pony save for 5 to 5
UDP: Sending the ponyData for 5 to 4 ### Sent twice
UDP: Sending pony save to 5
UDP: Sending the ponyData for/to 5
UDP: Ping timeout (16.358s) for 5 (player tux3)
UDP: Saving ponies for 5 (tux3)
UDP: Removing netview 5 to 4
==> Apparently thr bug appears when two players are connecting on the same map at the same time.
==> The first player is not instantiated yet, but already added to the map
==> When the second player enters, it instantiates itself to everyonee in the map, including the first player
==> Then the first player finish loading and instantiates everyone in the map for himself, including the second player. The second player is instantiated twice here.
===> Not instantiating ourselves to players that are not fully loaded when joining a map should fix this
====> Change player.inGame to be an uint. 0 means not in game, 1 means loading a map, 2 means loaded.
====> When joining a map, only instantiate to players who are fully loaded

=> Using the load server command doesn't teleport to the correct position. Fixed.

=> ping timeout bug log :
Reading config file ...
Loaded 21 vortex in 9 scenes
Starting TCP login server ...
Starting UDP game server ...
Loading players database ...
Got 5 players in database
Server started
TCP: New client connected
TCP: Session closed by client
TCP: Received non-HTTP request
TCP: Client disconnected
TCP: New client connected
TCP: Session closed by client
TCP: Received non-HTTP request
TCP: Client disconnected
TCP: New client connected
TCP: Login request received :
IP : 127.0.0.1
Username : tux3
Passhash : efc8ed71e9d9f3039f06d43133ded18579dd31d5
TCP: Login successful, sending servers list
TCP: Client disconnected
TCP: New client connected
TCP: Login request received :
IP : 127.0.0.1
Username : tux3
Passhash : efc8ed71e9d9f3039f06d43133ded18579dd31d5
TCP: Login successful, sending servers list
TCP: Client disconnected
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 1/1
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 0.0619929
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 2/2
UDP: Ping received from 127.0.0.1:58974
UDP: Last ping Dtime : 0.0310065
UDP: Sending characters data to 1
UDP: Sending characters data to 2
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 3.94701
UDP: Ping received from 127.0.0.1:58974
UDP: Last ping Dtime : 3.994
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 3.99299
UDP: Ping received from 127.0.0.1:58974
UDP: Last ping Dtime : 3.993
UDP: Saving ponies for 1 (tux3)
UDP: Loading scene "RaritysBoutique" to 1
UDP: Sending the 46 init messages
UDP: Saving ponies for 2 (tux3)
UDP: Loading scene "RaritysBoutique" to 2
UDP: Sending the 46 init messages
UDP: Sending entities list to 2
UDP: Send instantiate for 1 to 2
UDP: Send instantiate for 2 to 2
UDP: Unknow data received : 4d000018000100044804001800080100
UDP: Sending pony save to 2
UDP: Sending the ponyData for/to 2
UDP: Sending entities list to 1
UDP: Send instantiate for 1 to 1
UDP: Send instantiate for 2 to 1
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 4.00901
UDP: Sending pony save to 1
UDP: Sending the ponyData for/to 1
UDP: Unknow data received : 4d000018000200044806001800080200
UDP: Unknow data received : 4d000018000200044806001800080200
UDP: Sending pony save for 2 to 1
UDP: Sending the ponyData for 2 to 1
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 4.072
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 3.916
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 4.009
UDP: Ping timeout (16.498s) for 2 (player tux3)
UDP: Saving ponies for 2 (tux3)
UDP: Removing netview 2 to 1
UDP: Request from unknow peer rejected : :58974
Can't refresh player before sendMessage, aborting
UDP: Ping received from 127.0.0.1:58973
UDP: Last ping Dtime : 4.00999

=> Maybe this is the udp module grouping datagrams from the two peers, then calling receiveMessage for the first received wich is always the same
==> If that's the problem, we should check boundaries of the messages in udp and as long as we have complete messages received for a peer, call sendMessage
===> We're probably failing because we receive some messages in the wrong order !
===> The client sends messages with seq X and X+1, but we receive X+1 first, and then X wich appears to be a duplicate. Client keeps resending it until we ack, but we never ack.
====> Print a warning when we get a message in the wrong order (X+1 where the current seq is X-1), but don't change the seq.
====> This way when we receive X+1 we keep a lastSeq of X-1, wich still allows us to receive X-1

=>  Add the vortexes Everfree1 / Everfree3
=> TODO: Add a login server setting to forward the login/password checking to a remote login server.
==> Also get the game servers list from that remote server, then.
===> Forward to the remote login only when we detected a correct login request! You can just recreate the Content-Length header.
===> You can't just forward everything, or you'd risk forwarding the remote login's reply back to him
===> Instead if we get a correct login request, forward to the remote.
===> if we get a forwarded reply, send back to the client. (replies have the Server: header)
====> We need a way to find wich remote reply was for wich client. Since multiple clients use the same remote we need something else
====> The sesskey in the reply contains a private server hash + the original passhash. We just need to find who's passhash it was.
====> Add the clients to tcpPlayers before sending. Then at reception find their IP/port with the passhash
====> Then find the socket matching this IP/port and send back the reply

=> In the settings.ini you can use for example LoginServer=1.2.3.4:56 and SkipLogin=True

=> The vortex Cloudsdale -> Canterlot lands a little too low, you land under the ground.
=> Fix the vortexes in Everfree.

=> Definitely fix the instantiation code. Tons of bugs.
==> Mutexes. If you don't do this atomically, it's hell.

=> We probably want to ensure reliable UDP messages like the chat actually are ACK'd

=> TODO: Hey ! We could add the official LoE server as the default remote login in server.ini ! Disabled of course.

=> Between stages 1 and 2, only send his own info to a client
=> Just after entering stage 2, spawn everyone else on the client
=> Anything that happens between stage entering stage 2, and the spawning of everyone else on the client should be atomic.
==> The problem is with the ponySave/ponyData, not the instantiates. 
==> Looks like we're supposed to only send the ponySave/ponyData of the last instantiate we did. Check the exact received massage (shark)
===> Looks like we're only saved from the infinite loop by the 4D messages being rejected, while they also contain a 48 !

=> Filter to keep only interesting udp messages (WARNING: Will skip sync/ack messages that also contain another message)
=> Removes position sync, 
=> ip.proto==UDP && !data.data matches "^\x01" && !data.data matches "^\x86" && !data.data matches "^\x81" && !data.data matches "^\x82" 

=> Instantiate a pegasus and a unicorn with the same colors in the same place. Take a picture. Free Alicorn OC. Autism included.

=> 48 08 is just the message that means "Finished instantiating" ! 48 06 is "finished room change"

=> Read what the difference is between Sequenced, Ordered, Reliable ands the combinations

=> Most of the interesting enums are in Shared or Data
public class AccessLevel
{
	public const byte Default = 0;
	public const byte Player = 1;
	public const byte TeamMember = 2;
	public const byte Moderator = 3;
	public const byte Admin = 4;
}

public enum CharacterType : byte
{
	None,
	EarthPony,
	Unicorn,
	Pegasus,
	Moose
}

public enum ChatType
{
	None = 0,
	Untyped = 1,
	System = 2,
	General = 4,
	Local = 8,
	Party = 16,
	Guild = 32,
	Whisper = 64
}

public enum DamageType : ushort
{
	Physical = 0,
	Magical = 1,
	Poison = 2,
	Grass = 4,
	Psychic = 8,
	Ice = 16,
	Fire = 32,
	Ground = 64,
	Steel = 128,
	Dragon = 512
}

public enum Stats : byte
{
	None,
	Health,
	HealthRegen,
	Energy,
	EnergyRegen,
	Attack,
	Dodge,
	Armor,
	MagicResist,
	Resiliance,
	Fortitude,
	Evade,
	Tension,
	Speed,
	MagicCasting,
	PhysicalCasting,
	Taunt,
	Unspecified = 255
}

public enum Status : byte
{
	None = 0,
	Paralyzed = 1,
	Afraid = 2,
	Poisoned = 4,
	Burning = 8,
	Frozen = 16,
	Bleeding = 32
}

public enum Target : byte
{
	None = 0,
	Enemy = 1,
	Friendly = 2,
	Self = 4,
	Cloud = 8,
	MyPet = 16,
	FriendPet = 32
}

public enum WearablePosition : uint
{
	None = 0u,
	Tail = 1u,
	Pants = 2u,
	FrontSocks = 4u,
	BackSocks = 8u,
	Saddle = 64u,
	Necklace = 256u,
	Mouth = 512u,
	Eyes = 2048u,
	Ears = 4096u,
	FrontKnees = 8192u,
	BackKnees = 16384u,
	FrontShoes = 16u,
	BackShoes = 32u,
	Shirt = 128u,
	Mask = 1024u,
	SaddleBags = 1073741824u,
	Hat = 2147483648u
}

public class SharedIDs
{
	public const byte InvokeScript = 49;
	public const byte BeginMagic = 60;
	public const byte PerformMagic = 61;
	public const byte CancelMagic = 62;
	public const byte StatCurrent = 50;
	public const byte StatMax = 51;
	public const byte PickupItem = 52;
}

=> Disable the chat filter (before sunday if possible)
=> Implement /stuck (teleport to spawn point).

=> When we load a room, we switch inGame to 1. When we get 48 06, we send the instantiates.
=> When we get 48 08, if inGame==1, we send the savegame and immediatly switch inGame to 2. If we get another 48 08, something's probably wrong.

=> Load room sequence :
Server sends load room
Client sends load room finished
Server sends instantiates and stats of current player

Client sends finished instantiate for another player
Server replies with worn items, stats, ponyData (and a 01 to sync pos)

Client sends finished instantiate for our player
Server replies with stats, ponyData, inventory, skills, stats again (?) (and a 01 to sync pos)

=> We need a queue of missing packets, and if we get a retransmission, check if it's a missing one.
==> Done (Player::udpRecvMissing). Should work.

=> Add reliable udp send. If we don't get an ACK in the next 3s, resend.
==> Have a queue of reliable messages sent.
==> Have a timer with the message as argument. If the message is still in the queue after X milliseconds (X=3000 ?), resend the message.
==> When we get an ACK for a message in the queue, remove the message and send the next one.
===> If there are multiple messages waiting in the queue, group them and send them all at once.

=> UDP message grouping
==> When enabled, have a 100ms udpGroupingTimer timer.
==> When adding a message, stop udpGroupingTimer, add the message to the channel's buffer, and restart udpGroupingTimer
==> When udpGroupingTimer times out, enqueue and clear the buffer, then start the reliability timer (3000ms)
==> When adding, if the buffer would be > 1024, call udpGroupingTimer's callback manually, add to the buffer, and restart udpGroupingTimer.

=> Use the current /mlp/ server by default for "Online" instead of tux3.bounceme.net

=> The ACK is 1/2 of the real seq value.
=> When we get an ACK, for each ACK'd message in the ack message
==> Parse the messages in the first grouped message
===> For each message that matches the ACK, remove it from the grouped message (with left and mid)

=> If after removing the ACK'd messages, the first message isn't empty, restart the timer
=> If the first is empty, remove it.
=> Now if there's another message in the queue, send it and restart the timer

=> If you get weird casting error, remember that to reinterpret a signed X bit as an unsigned X bit, you must cast to (unsignedX_t)
=> If you cast to a larger value like (unsigned2X_t) you'll get an unexpected result. 

=> Add the /mlp/ server as the default online server

=> The "Local Login" option is just a direct connection to the game server (UDP) on localhost:14000
=> The connect message (with sesskey) is "830000980004504e65740f3d7a656128b18044a884450000"

=> Sometimes you still get the ponySave/ponyData twice.
==> See Chips log filtered for ID 31, line 630 and onward.
==> See: 
UDP: Sending entities list to 31
UDP: Send instantiate for 31 to 31
UDP: Discarding double message (-0) from 31
UDP: Sending entities list to 31
UDP: Send instantiate for 31 to 31
udpResendLast locking
udpResendLast unlocking
UDP: Sending pony save to 31
UDP: Sending the ponyData for/to 31
UDP: Sending pony save to 31
UDP: Sending the ponyData for/to 31
UDP: Discarding double message (-0) from 31
UDP: Sending pony save to 31
UDP: Sending the ponyData for/to 31
UDP: Discarding double message (-0) from 31
UDP: Sending pony save to 31
UDP: Sending the ponyData for/to 31
==> Add a check so we can only send the entity list once or something.

=> Restarting UDP server.
=> Later : Error sending pony save, netview id not found
==> We should just give up instead of restarting if it fails. And disconnect the offending player.
===> Not really fixed, but we can safely ignore the error.

=> Fix all of chip's errors. See all the logs.
=> We should ignore disconnected players, never ever reply to them
Reading config file ...
Loaded 39 vortex in 17 scenes
Starting TCP login server on port 1031 ...
Starting UDP game server on port 1039 ...
Loading players database ...
Got 21 players in database
Server started
UDP: Request from unknown peer rejected : :56400
UDP: Error sending last message
Restarting UDP server ...
UDP: Connecting ...
UDP: Connected to client
UDP: Starting game
UDP: Set id request : 1/1
...
===> Not really fixed, but we can safely ignore the error.

=> Do Chip's idea of multiple tabs.
One with everything, one with server commands, one with player info.
=> Or maybe don't. Just remove some useless output

=> TODO: Save the logs to a text file
==> Filename should be the system time

=> When disconnecting players on server exit, save the ponies first !

=> Update the DLL to download static data from the private server instead of the officials

=> Fix chat bug when you're alone or just entered, either no name or not working at all

=> Fling then landing : 
4e 0000 3800 0100 ca 01000000
4e 0200 3800 0100 ca 00000000

=> Log of the discarded message / crab pony bug :
UDP: Loading scene "GemMines" on 1
UDP: Loading scene "GemMines" on 2
UDP: Sending entities list to 1
UDP: Send instantiate for 1 to 1
UDP: Send instantiate for 2 to 1
UDP: Sending pony save to 1
UDP: Sending the ponyData for/to 1
UDP: Unknown message received : 4d00001800020004
UDP: Sending pony save for 2 to 1
UDP: Sending the ponyData for 2 to 1
UDP: Sending entities list to 2
UDP: Send instantiate for 1 to 2
UDP: Send instantiate for 2 to 2
UDP: Unknown message received : 4d00001800010004
UDP: Sending pony save for 1 to 2
UDP: Sending the ponyData for 1 to 2
UDP: Sending pony save to 2
UDP: Sending the ponyData for/to 2
UDP: Discarding double message (-0) from 2
UDP: Message was : 480a001800080200
UDP: Sending pony save to 2
UDP: Sending the ponyData for/to 2
==> 48 0a00 1800 08 0200
===> Wireshark says the server received the message twice 
===> (the game sent it twice at a very short interval, before the game was even able to reply to the first one)
===> But the server ACK'd the message 3 times, not two. Looks like the "discarded" message was still processed.
====> Fixed. We weren't returning after discarding a double message, so it was still processed.

=> What's with the login server adding tons of shit to players.dat ? Fixed.

=> Search all the casts (search <<8 or msg[ or something) and cast correctly to quint8 first
==> Fixed.

=> New example of spells (54 C3) : c300020000000a000000000000000b00000000000000

=> Message received when using ground pound with a pegasus targeting himself : 4d 0000 6800 0100 3d0a000000d5652e460100
==> Not sure if this is related. The tornado gives nothing, maybe we need to target a monster first.
===> Check teleport.
====> Teleport crashed the server ! Fixed.
====> Teleport gives 4d 0000 b800 0200 3d 02000000e0903346464533421dd61241100f5fc2

=> Skill with target position
4d 0000 b800 	Header
0200 			Netview ID
3d 				RPC Id
02000000 		Skill ID (Teleport)
e0903346		Timestamp
46453342		Target X
1dd61241		Target Y
100f5fc2		Target Z

=> Skill with target netview id
4d 0000 6800 	Header
0100 			Netview ID
3d				RPC Id
0a000000		Skill ID (Ground smash)
d5652e46		Timestamp
0100			Target netview id

=> Expected reply :
[Rpc (61)] (0x3D)
private void RpcPerformMagic (NetIncomingMessage msg)
{
	int spell = msg.ReadInt32 ();
	this._vecSerializer.OnDeserialize (msg);
	Vector3 vector = this._vecSerializer.vector3;
	int num = msg.ReadInt32 ();
	double num2 = msg.ReadTime (false);
	NetworkView networkView;
	if (msg.RemainingBits == 16L && NetworkView.Find (ref msg, out networkView))
	{
		GameObject gameObject = networkView.gameObject;
		this.PerformSkill (spell, num, gameObject);
		return;
	}
	this.PerformSkill (spell, num, vector);
}

=> Donut Steel pos : 24.2031 -1.16802 -55.8526 in RaritysBoutique
==> When we try to talk to Donut Steel, we get 4d 0400 1800 0000 31 ! (0000 is Donut's netview id)

=> The unknown 4d message when you enter could be the client asking for the animations of the other players.

=> Go look at PonyQuest. Seriously. Apparently there's a whole language and parser for quests/npcs/.. and it was already in ponyquest.

=> The global chat isn't actually global ! Make it global, and implement the real global chat.
==> Fixed

=> TODO: If we can't find loe.exe/LoE.exe/LoE-Windows-x64.exe/LoE-Windows.exe/LoE-Windows-x86.exe/loe.x86/loe.x86_64, show a warning
==> Because the user maybe didn't understood that he had to merge the folders.

=> Item 73 is raincloud hat. Give it to everyone by default.
==> Find a way to wear stuff. Inventory works, but not wearing.


[Rpc (5)]
private void Inventory (NetIncomingMessage msg)
{
	if (this.inventory == null)
	{
		this.inventory = new Inventory ();
	}
	this.inventory.OnDeserialize (msg);
	if (base.netView.IsMine)
	{
		InventoryBehaviour.myInventory = this.inventory;
		InventoryBehaviour.myInventoryBehaviour = this;
	}
	for (int i = 0; i < this.inventory.WornItems.Length; i++)
	{
		if (this.inventory.WornItems [i] != null)
		{
			byte arg = Item.ConvertWearablePositionToSlot (this.inventory.WornItems [i].WearableSlots);
			this.ItemWorn (this.inventory.WornItems [i].ID, arg);
		}
	}
}

// Inventory
public void OnDeserialize (NetIncomingMessage message)
{
	this.MaxSize = message.ReadByte ();
	byte b = message.ReadByte ();
	this.Items = new InventoryItem[(int)this.MaxSize];
	for (int i = 0; i < (int)b; i++)
	{
		InventoryItem inventoryItem = new InventoryItem ();
		byte b2 = message.ReadByte ();
		inventoryItem.OnDeserialize (message);
		this.Items [(int)b2] = inventoryItem;
	}
	ItemArraySerializer itemArraySerializer = new ItemArraySerializer ();
	itemArraySerializer.OnDeserialize (message);
	this.WornItems = itemArraySerializer.Items;
	this.Bits = message.ReadInt32 ();
}

// Item array serializer
public void OnDeserialize (NetIncomingMessage message)
{
	byte b = message.ReadByte ();
	this.Items = new Item[(int)b];
	byte b2 = message.ReadByte ();
	for (int i = 0; i < (int)b2; i++)
	{
		byte b3 = message.ReadByte ();
		int key = message.ReadInt32 ();
		Item item;
		if (StaticData.Items.TryGetValue (key, out item))
		{
			this.Items [(int)b3] = item;
		}
	}
}

=> We sent for the raincloud : 	54 1200 c800 0100 050c01004900000001000000200100490000000a000000
05
0c
01
00
49000000
01000000
20
01
00
49000000
0a000000
==> It should work .. What's wrong ?
===> The items sometime works, sometime don't. Depending on the order, the indexes, what we sent, etc...
===> The goggles tends to not be worn if we change anything. 
===> Sometimes the first item becomes an apple even if we never asked for this. Sometime items aren't in the inventory.

=> When we speak in the local chat, we don't have a name !
==> Maybe just print the player name when we're about to send a message
==> CharacterId is a ReadInt32, is ReadInt32 always 32 bit ?
public void OnDeserialize (NetIncomingMessage message)
{
	this.chatType = (ChatType)message.ReadByte ();
	this.name = message.ReadString ();
	this.text = message.ReadString ();
	this.CharacterId = message.ReadInt32 ();
	this.accessLevel = message.ReadByte ();
}
=> Fixed

=> Fix setMaxStat/.. etc not actully sending data about the refresh, but always about the player to the player. Add an overload.

=> Asking to wear the goggles, at pos 1 in the inventory
4d 0600 2800 
0100 08 0b 01
=> Asking to wear the bag at pos 3 in the inventory
4d 1800 2800 
0100 08 1f 03

=> We could use ranged singles instead of full absolute coordinates now that we have disunity to get the bounds
==> Upload some desunity'd assets on github.

=> Sort those damn folders. It doesn't make any sense.

=> Maybe we could just close the msgbox when the player doubleclicks play instead of reloading.

=> Syncing the player with himself in doSync (comment the i==j->continue) fixes #16 !
==> I don't even, but it seems to work now.

=> The new DLL that limits the chat to 50 messages doesn't fix the problem
=> If you send enough chat messages quickly, there's still a infinite send loop.

=> Donut Steel's old ponyData is in hex :
0b446f6e757420537465656c0402b70000000000000000000000ca1a0017ff00032e03ff050072ff000c000b0000000000cdcc8c3fff9f
=> In base64 C0RvbnV0IFN0ZWVsBAK3AAAAAAAAAAAAAADKGgAX/wADLgP/BQBy/wAMAAsAAAAAAM3MjD//nw==
=> Donut Steel as a pony's ponydata is in base64 : K2sAXPwDDLgM/BcAyP0DMCwAgFsAAMBmZsYf0P/Pn85pqMlnJ4JYAA==
=> In hex : 2B6B005CFC030CB80CFC1700C8FD03302C00805B0000C06666C61FD0FFCF9FCE69A8C96727825800

=> Import ponycode : 
private void ImportPonycode (string ponycode)
{
	try
	{
		this.index = 0;
		this.bits = new BitArray (Convert.FromBase64String (ponycode));
		PonyData ponyData = new PonyData ();
		ponyData.race = (CharacterType)this.GetBits (2);
		ponyData.hairColor0 = this.IntToColor (this.GetBits (24));
		ponyData.hairColor1 = this.IntToColor (this.GetBits (24));
		ponyData.bodyColor = this.IntToColor (this.GetBits (24));
		ponyData.eyeColor = this.IntToColor (this.GetBits (24));
		ponyData.hoofColor = this.IntToColor (this.GetBits (24));
		ponyData.Mane = (short)this.GetBits (8);
		ponyData.Tail = (short)this.GetBits (8);
		ponyData.Eye = (short)this.GetBits (8);
		ponyData.Hoof = (short)this.GetBits (5);
		int id1 = this.GetBits (10);
		int id2 = this.GetBits (10);
		int id3 = this.GetBits (10);
		ponyData.CutieMarks = new CutieMark[]
		{
			this.cutieMarkArray.FirstOrDefault ((CutieMark cm) => cm.ID == id1),
			this.cutieMarkArray.FirstOrDefault ((CutieMark cm) => cm.ID == id2),
			this.cutieMarkArray.FirstOrDefault ((CutieMark cm) => cm.ID == id3)
		};
		ponyData.gender = (Gender)this.GetBits (2);
		ponyData.BodySize = BitConverter.ToSingle (BitConverter.GetBytes (this.GetBits (32)), 0);
		ponyData.HornSize = BitConverter.ToSingle (BitConverter.GetBytes (this.GetBits (32)), 0);
		StringBuilder stringBuilder = new StringBuilder ();
		for (int i = this.index; i <= this.bits.Length - 6; i += 6)
		{
			stringBuilder.Append (this.ConvertChar ((char)this.GetBits (6), false));
		}
		this.characterName = stringBuilder.ToString ();
		ponyData.name = this.characterName;
		this.AssignSelectorsToPonyData (ponyData);
	}
	catch
	{
		MessageBox.CloseTopBox ();
		MessageBox.OK ("Error", "Invalid PonyCode!\nMake sure you copied the PonyCode correctly and try again.");
		MessageBox.OK (string.Empty, string.Empty);
	}
}

=> PonyData
public void OnDeserialize(NetIncomingMessage msg)
{
    this.name = msg.ReadString();
    this.race = (CharacterType) msg.ReadByte();
    this.gender = (Gender) msg.ReadByte();
    this.CutieMarks = (from id in new int[] { msg.ReadInt32(), msg.ReadInt32(), msg.ReadInt32() } select StaticData.CutieMarks[id]).ToArray<CutieMark>();
    this.hairColor0 = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.hairColor1 = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.bodyColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.eyeColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.hoofColor = new Color32(msg.ReadByte(), msg.ReadByte(), msg.ReadByte(), 1);
    this.Mane = msg.ReadInt16();
    this.Tail = msg.ReadInt16();
    this.Eye = msg.ReadInt16();
    this.Hoof = msg.ReadInt16();
    this.BodySize = msg.ReadFloat();
    this.HornSize = msg.ReadRangedSingle(0f, 2f, 0x10);
}

=> Fix bug at shutdown. Again.
==> Fixed (?)
=> Finish ponyCode in quests
=> Add Flan in canterlot
=> PonyCode: 0mObdm8W3adDm0e2/P//MwAEAGMAAECVIL+fkKe8n28BGg==

=> ConvertChar
private char ConvertChar (char c, bool direction = true)
{
	if (direction)
	{
		if (c >= 'a' && c <= 'z')
		{
			return c - 'a';
		}
		if (c >= 'A' && c <= 'Z')
		{
			return c - 'A' + '\u001a';
		}
		if (c >= '0' && c <= '9')
		{
			return c - '0' + '4';
		}
		return '>';
	}
	else
	{
		if (c >= '\0' && c <= '\u0019')
		{
			return c + 'a';
		}
		if (c >= '\u001a' && c <= '3')
		{
			return c + 'A' - '\u001a';
		}
		if (c >= '4' && c <= '=')
		{
			return c + '0' - '4';
		}
		return ' ';
	}
}

=> Player called "Aaa Bbb", ponyCode is /fsD/v9/6gP+A/7bT4T1HgwEgA0AAGCKR7afg+LCHw0A/C0IAA==
=> Remaining bits : 1 00001101 00000000 11111100 00101101 00001000 00000000
=> 100001 101000 000001 111110 000101 101000 010000 000000 0

=> Player called "Aaaaa Bbbbb", /gO2/3/KA/53/gNaK7duNCQEAAsAAMBch8Ef2lfDHw0AAMDfgiAIAA==
=> 1 0000 1101 0000 0000 0000 0000 1100 0000 1101 1111 1000 0010 0010 0000 0000 1000 0000 0000
=> 100001 101000 000000 000000 011000 000110 111111 000001 000100 000000 010000 000000 0
=> 1000011010000000000000000110000001101111110000010001000000000100000000000

=> Well, fuck. Let's just make a getPonyData command and ditch the ponyCode entirely

=> Trying to talk to Flan : 4d 0400 1800 0100 31
=> She's NetviewId 01
=> This is a RPC call 0x31 to netview Id 0100
=> Sent from NetworkCharacterController::ApplyNetworkCharacter
=> We probably need to send a reply that triggers DialogBox methods
=> See in NetworkMenu, the 4 dialog commands
=> Probably setDialogMessage then setDialogOptions then beginDialog
=> That's it. After we beginDialog, we can just use setDialogMsg to update the dialog.
=> Don't use beginDialog before setDialogMsg.

=> The 4D message at startup is just asking for the worn items !
=> Only send worn items when we receive the 4D 04, not after a 48 08!
=> Fixed for other players
=> Maybe we should only send the player's inventory/worn when asked ?
==> Apparently we shouldn't. It breaks at least the incentory.

=> Lidgren. "Trace" what happens when we send/receive a message
=> Roughly what functions are called, what happens.
=> See NetConnection.cs, NetPeer.Send.cs

=> lastId should start at 1, but always be 0 for NPCs. lastNetviewId should start at 0.

=> Ensure that all network uses of netviewId and id are casted to quint8 correctly

=> TODO: BUG: Sometime when there are two player, one will not see the other move
==> When both use the chat, all the messages will appear to come from the same player (the one that isn't refreshed on the other's screen)
===> Maybe we should make all operations on lastId and lastNetviewId atomic, now.
====> That's not the problem, but we still needed to do it. Especially with the reloadNPC command.
==> Maybe we shouldn't sync the player with himself (uncomment if j==k)
==> But instead send one sync message during instantiate/savegame, like in the wireshark logs
==> Maybe the game is waiting for just one sync message, and that's why syncing with ourselves fixed #16

=> In sendChatMessage we send a netviewId on 4 bytes ! Shouldn't we send id then netviewId ?

=> When people get stuck on login, it looks like we're not sending the data correctly...

=> On the quests scripts, when we get to a say line, keep EIP on the say line, read the eventual answer lines without changing EIP, send setDialogMsg, setDialogOptions, beginDialog, then return with EIP still on the say.
=> When we get a reply to a say, if there was an answer, jump to the corresponding label, if there wasn't an answer, increment EIP and run the script from there.
=> dialog options is just a serialized array of strings
=> Once you set a NPC name, if you change the name in another setDialogMsg, it'll open another dialog at the side of the first one.
==> Then you can update a dialog's message by reusing a name. Adding a new name will replace the oldest dialog with the new name/message.
===> We're supposed to do beginDialog, then setDialogMsg once for updating, twice for focus, then setDialogOptions once eventually.
===> Then again to update the current msg/add a new message on the side setDialogMsg once, twice if you need to shift focus to the eventual new msg, and setDialogOtions eventually
===> Then rinse&repeat as appropriate and endDialog to exit.

=> sayIcon iconId : sets the NPC's sprite for say

=> RunScript request for Donut Steel : 4d 0200 1800 0000 31
=> Replying to Donut Steel, no answer : 46 0800 0800 0b
=> Replying to Donut Steel, answer 0 :  46 0200 2800 0c 00 00 00 00

=> Klondike Hicks ponyData message : 54 0200 e801 0700 c8 0e4b6c6f6e64696b65204869636b7301030000000000000000000000009db3ab9db3abd1982e24dbb1d1982e0300030002000000cdcc8c3fff7f
=> 0e 4b6c6f6e64696b65204869636b73
=> 01 03 
=> 00000000 00000000 00000000 (blank flank)
=> 9d b3 ab 9d 
=> b3 ab d1 98 
=> 2e 24 db b1 
=> d1 98 2e 03 
=> 00 03 00 02 
=> 00 00 00 cd 
=> cc 8c 3f ff 7f

=> Save the quests data in data/players/$NAME/quests.dat (alongside ponies.dat)
=> Format :
==> Numbers are big endian
==> The file can have one entry per pony, each entry starts with the name of the pony (not id/offset, since we can delete/insert and it'd be a mess)
==> The name is encoded in the form size + data. Then immediately following the name is the number of quests saved in the entry on 2 bytes
==> Each quest consist of an ID on 2 bytes and a state on 2 bytes. The ID is the unique ID of the state.

=> The inventory/money will be in data/players/$NAME/inventory.dat
==> Numbers are big endian
==> The file can have one entry per pony, each entry starts with the name of the pony, like the quests file
==> The entry is immediatly followed by the money on 4 bytes, then the serialized inventory (1B size) and finally the serialized worn items (1B size).

=> When we're done with the inventory save/loading, we can finally implement the usefull quest commands !

=> Create a getVUint32Size(QByteArray) instead of calculating it ourselves everytime
=> Create a set of getIntXX(QByteArray) functions, instead of rewriting this inline ourselves everytime

=> Add a (10s?) cooldown to the roll command

=> Test the new QuestScript commands.

=> When you create a new player & pony, the first time you play the server doesn't get your pony's name. 
==> That's probably what caused people writing in the chat without name/blank name
==> Now it's causing the save files to have a null name e.g. in the inventory !
===> Fixed.

=> Fix bugs in loadInventory

=> Default inv is :
Item 73 (pos 0) : 1
Item 17 (pos 1) : 1
Item 62 (pos 2) : 1
Item 60 (pos 3) : 1

=> N++'s ASCII control characters :
NUL = 0
SOH = 1
STX = 2
ETX = 3
BS = 8?
SI = 15?

Update Donut Steel's quest

He now gives you 5 bits the first time you talk to him.
I'm still terrible at writing dialogs. PRs are very welcome.

=> We can't unwear now !
=> The worn inventory is saved, and we have no way to remove a worn item.

=> Maybe we should just save the inventory/quests of all the ponies of a player at the same time, to avoid concurrency problems ?
==> Yeah, but no. Just add a saveFilesMutex to the player, so if he's logged in twice it still works.
==> Or just don't allow people to log in twice with the same account. I mean, who does that ?
===> Yeah, probably half the people on the private server.
===> Just add a mutex.
====> Or maybe that's not really a bug. Slots are on the same thread in the event loop by default. Are we even threading ?

=> Investigate AAAAAAAAAAAAAAAAAAAAFAAAgAIAAKBmZsYfAAAAAA== !

=> Buck ponycode : OTg4NERYHGtkzMzMHGtkEBQAAAAAAGDsjcCf+i+/n40SFA==
=>Pos : x=45.2917, y=-193.843, z=131.404
=>Rot : x=0, y=1.50304, z=0, w=0
=>PonyData BEJ1Y2sBAwAAAAAAAAAAAAAAAA4ODg0RFscaGTMzM8caGQQABQAAAAAA2BuBPy9

=> BUG: When a player disconnects, if he's still the cmdPeer, next time we enter something in the server console it'll crash and burn.
=> We should set cmdPeer to nullptr on playerCleanup is he's the player leaving

=> TODO: BUG: Don't allow someone to create a pony with the same name as a NPC or another player ?

=> Astral Charm ponyCode : YmqvY2qv/0vrAf5//0vrKSgEAGYAAMATKL+fZmamH02aImDxuQOIGA==

=> Teleport example.
=> Skill message: 4d0400b80006003d02000000fe2afa41e6958fc27004ff3cd26d1943
=> Received unknown message: 4e000078000600c9149a91c2a7949c3eb7161843
==> This one looks like it's the animation request, asking to play the teleport sound / flashing animation
4d 0400 b800
0600		Target netviewId
3d			RPC ID
02000000	Skill/spell ID
fe2afa41	Timestamp
e6958fc2	X (float)
7004ff3c	Y (float)
d26d1943	Z (float)

=> Expected reply :
[Rpc (61)] (0x3D)
private void RpcPerformMagic (NetIncomingMessage msg)
{
	NetworkView view;
	int spell = msg.ReadInt32 ();
	this._vecSerializer.OnDeserialize (msg);
	Vector3 target = this._vecSerializer.vector3;
	int upgrade = msg.ReadInt32 ();
	double num2 = msg.ReadTime (false);
	NetworkView networkView;
	if (msg.RemainingBits == 16L && NetworkView.Find (ref msg, out networkView))
	{
		GameObject gameObject = networkView.gameObject;
		this.PerformSkill (spell, num, gameObject);
		return;
	}
	this.PerformSkill (spell, num, vector);
}
==> Okay so if the skill is 02 (teleport) we need to parse the message and rebuild a correct reply

=> Emotion codes :
Afraid = 2
Angry = 3
Blank = 8
Bored = 9
Concerned = 38
Confident = 25
Confused = 20
Covertous = 36
Crazed = 17
@Default/Neutral/None = 0
Depressed = 27
Derp = 32
Disgusted = 15
Drunk = 30
Excited = 10
Flirty = 28
Greedy = 19
Happy = 1
Hopeful = 23
Incredulous = 33
Introspective = 31
Irritated = 16
Lovestruck = 37
Mischievious = 5
Nervous = 14
Paralyzed = 34
Pouty = 18
Proud = 12
Relaxed = 13
Sad = 4
Sarcastic = 29
Serious = 7
Shocked = 21
Sick = 35
Silly = 11
Smug = 24
Sorry = 26
Surprised = 6
Tired = 22

=> I've seen the inventory getting weird entries, maybe we should test a little more thoroughly to make sure it always works.
=> Confirmed. Probably worn items.
==> Fixed.

=> Unwear. We can't publish 0.5.0 without unwear.
4d 0c00 2800
0600			NetviewId
09				RPC number
0400			Item slot (index)

=> Do the item wearing properly. We need some kind of DB of items and their wearable slots
=> Wearable slots :
None = 0
Tail = 0x1
Pants = 0x2
FrontSocks = 0x4
BackSocks = 0x8
FrontShoes = 0x10
BackShoes = 0x20
Saddle = 0x40
Shirt = 0x80
Necklace = 0x100
Mouth = 0x200
Mask = 0x400
Eyes = 0x800
Ears = 0x1000
FrontKnees = 0x2000
BackKnees = 0x4000
SaddleBags = 0x40000000
Hat = 0x80000000
=> We'll parse the items.xml instead of maintaining our own DB.
=> Okay now when we wear, check that we have this item, then check that the required wearing slots are free, and send the wear request
=> When we unwear, add the item back in the inventory, and free the appropriate wearing slots
=> When we wear, send the wear RPC request to update the client

=> When loading the inventory, we should recalculate the wornSlots flag.

=> In the quest interpreter, we sometime send redundunt messages. 
=> E.g calling addInventoryItem that does notify the client, then notifying ourselves again with sendInventoryRPC (slow as fuck).

=>  When putting it on, Ellowee's hat appears correctly. After a /stuck it doesn't appear. It's worn, invisible and you can't unwear it.
==> Apparently this could be a problem with sendWornRPC. It works better without it !
==> Fixed.

=> Unwear sometime doesn't works correctly. Fixed

=> Use default inv. Put on glasses. Take book at from Moose, put on. Remove stuff and some items can overwrite other items when unwearing !
=> From then on further inv operations are chaotic
==> Fixed

=> Update the README.

=> Harden before release. In particuular the inventory w/ worn items and quest save files need further testing.

=> Quests can apparently get corrupted.
==> Fixed. No actual corruption possible, but still a read error.

=> Bump the version number, make a release

=> Login bug. It doesn't finds the same passhash when you create the account and when you login next
That's really weird, we actually receive different passhashes. If we erase and rewrite the password manually, it's the same as the first time
But if we use the prefilled password (not remember password, just the prefilled field) we get a different passhash server side!
=> Username: "1", password: "1", without quotes. 2 results :
=> commfunction=login&username=1&passhash=17ba0791499db908433b80f37c5fbc89b870084b&version=201401
=> commfunction=login&username=1&passhash=356a192b7913b04c54574d18c28d46e6395428ab&version=201401
==> Fixed. The passhashes being different is a bug in the game.

=> TODO: Might want to use color in the log for errors and warnings. As an optional parameter to logMessage maybe.

=> TODO: BUG: Teleporting with a target pony instead of destination is not implemented and destination is semi-random

=> TODO: setPeer/listPeers should use netviewIds, not Ids

=> We accept loading a scene with a case insensitive name, but later we compare with case sensitivity
=> So if a player does load RaritysBouTIQUE, he'll never sync with anyone else since we compare scene names case sensitive !
==> We should just toLower everything.
===> Fixed

=> TODO: We should totally log the version of the client when they login. Just in case.

=> In a 'say' or 'answer' questscript command, replace $PLAYERNAME by the name of the player. We need it for Spud, in Astral Charm's quest.

=> Simulate UDP packet loss. In the send function, drop things randomly.
=> Use a #define w/ comments to make sure people don't accidentally enable this
==> Okay, first thing is connecting to the server. We should be able to get to the menu everytime even with 50% packet loss.
==> Okay we managed to reach the menu everytime with 75% packet loss ! 
==> Then at 75% it sometimes timeouts because we drop the pongs every 5s, but it works.
==> We even reached RaritysBoutique without a single bug at 75%!

=> TODO: Actually, we only simulate packet loss when sending, not when receiving ! 
=> Implement that too, when we're done fixing the mess with reliable sending.

=> Okay if I break the server's CutieMarks.xml but not the game's, I can trigger the "Downloading..." bug.
=> We have Cutiemarks, abilities and skills downloading, but items, recipes and atlas done.
==> The output log says "Deserialization of static data failed:System.ArgumentException: An element with the same key already exists in the dictionary."
==> Would be nice to tell the user. Especially if that's what caused this damn "Downloading..." bug most of the time.
===> Okay if we patch Data to store 1 in a static field (ldc.i4.1/stsfld) when there's this error, it should be possible.
===> Then in Twilight Sparkle we append an error to the StringBuilder when this field's value is 1 (ldsfld/brfalse->normal flow/append error/normal flow)
